Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program command
Rule 2     program -> command
Rule 3     program -> program function
Rule 4     program -> function
Rule 5     program -> error
Rule 6     command -> import STRING
Rule 7     command -> outcsv ID in STRING
Rule 8     command -> save ID in ID
Rule 9     command -> save LPAREN parlist RPAREN in ID
Rule 10    command -> search ID with ID as sql
Rule 11    command -> foreach ID in ID
Rule 12    command -> foreach ID COMMA ID in ID
Rule 13    command -> end
Rule 14    command -> return
Rule 15    command -> return expression
Rule 16    command -> continue
Rule 17    command -> if relexpression then
Rule 18    command -> else
Rule 19    command -> def ID LPAREN RPAREN
Rule 20    command -> def ID LPAREN parlist RPAREN
Rule 21    command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
Rule 22    command -> let ID EQUALS expression
Rule 23    command -> let ID EQUALS command
Rule 24    command -> let error
Rule 25    command -> list ID EQUALS LPAREN parlist RPAREN
Rule 26    sql -> SELECT
Rule 27    sql -> INSERT
Rule 28    sql -> UPDATE
Rule 29    expression -> variable
Rule 30    expression -> dbvariable
Rule 31    expression -> function
Rule 32    expression -> INTEGER
Rule 33    expression -> FLOAT
Rule 34    expression -> STRING
Rule 35    expression -> MINUS expression
Rule 36    expression -> LPAREN expression RPAREN
Rule 37    expression -> expression PLUS expression
Rule 38    expression -> expression MINUS expression
Rule 39    expression -> expression MULTIPLY expression
Rule 40    expression -> expression DIVIDE expression
Rule 41    expression -> expression POWER expression
Rule 42    relexpression -> expression LT expression
Rule 43    relexpression -> expression LE expression
Rule 44    relexpression -> expression GT expression
Rule 45    relexpression -> expression GE expression
Rule 46    relexpression -> expression EQUALS expression
Rule 47    relexpression -> expression NE expression
Rule 48    function -> ID LPAREN parlist RPAREN
Rule 49    variable -> ID
Rule 50    dbvariable -> DBID
Rule 51    parlist -> parlist COMMA expression
Rule 52    parlist -> expression

Terminals, with rules where they appear

COMMA                : 12 51
DBID                 : 50
DBPROVIDER           : 21
DIVIDE               : 40
EQUALS               : 21 22 23 25 46
FLOAT                : 33
GE                   : 45
GT                   : 44
ID                   : 7 8 8 9 10 10 11 11 12 12 12 19 20 21 22 23 25 48 49
INSERT               : 27
INTEGER              : 32
LE                   : 43
LPAREN               : 9 19 20 21 25 36 48
LT                   : 42
MINUS                : 35 38
MULTIPLY             : 39
NE                   : 47
PLUS                 : 37
POWER                : 41
RPAREN               : 9 19 20 21 25 36 48
SELECT               : 26
STRING               : 6 7 21 34
UPDATE               : 28
as                   : 10
connect              : 21
continue             : 16
def                  : 19 20
else                 : 18
end                  : 13
error                : 5 24
foreach              : 11 12
if                   : 17
import               : 6
in                   : 7 8 9 11 12
let                  : 22 23 24
list                 : 25
outcsv               : 7
return               : 14 15
save                 : 8 9
search               : 10
then                 : 17
with                 : 10

Nonterminals, with rules where they appear

command              : 1 2 23
dbvariable           : 30
expression           : 15 22 35 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 51 52
function             : 3 4 31
parlist              : 9 20 25 48 51
program              : 1 3 0
relexpression        : 17
sql                  : 10
variable             : 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program command
    (2) program -> . command
    (3) program -> . program function
    (4) program -> . function
    (5) program -> . error
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . search ID with ID as sql
    (11) command -> . foreach ID in ID
    (12) command -> . foreach ID COMMA ID in ID
    (13) command -> . end
    (14) command -> . return
    (15) command -> . return expression
    (16) command -> . continue
    (17) command -> . if relexpression then
    (18) command -> . else
    (19) command -> . def ID LPAREN RPAREN
    (20) command -> . def ID LPAREN parlist RPAREN
    (21) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (22) command -> . let ID EQUALS expression
    (23) command -> . let ID EQUALS command
    (24) command -> . let error
    (25) command -> . list ID EQUALS LPAREN parlist RPAREN
    (48) function -> . ID LPAREN parlist RPAREN

    error           shift and go to state 18
    import          shift and go to state 6
    outcsv          shift and go to state 3
    save            shift and go to state 7
    search          shift and go to state 14
    foreach         shift and go to state 5
    end             shift and go to state 12
    return          shift and go to state 9
    continue        shift and go to state 16
    if              shift and go to state 2
    else            shift and go to state 10
    def             shift and go to state 19
    connect         shift and go to state 1
    let             shift and go to state 11
    list            shift and go to state 15
    ID              shift and go to state 13

    function                       shift and go to state 8
    program                        shift and go to state 4
    command                        shift and go to state 17

state 1

    (21) command -> connect . ID EQUALS DBPROVIDER LPAREN STRING RPAREN

    ID              shift and go to state 20


state 2

    (17) command -> if . relexpression then
    (42) relexpression -> . expression LT expression
    (43) relexpression -> . expression LE expression
    (44) relexpression -> . expression GT expression
    (45) relexpression -> . expression GE expression
    (46) relexpression -> . expression EQUALS expression
    (47) relexpression -> . expression NE expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    relexpression                  shift and go to state 27
    variable                       shift and go to state 29
    expression                     shift and go to state 32

state 3

    (7) command -> outcsv . ID in STRING

    ID              shift and go to state 33


state 4

    (0) S' -> program .
    (1) program -> program . command
    (3) program -> program . function
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . search ID with ID as sql
    (11) command -> . foreach ID in ID
    (12) command -> . foreach ID COMMA ID in ID
    (13) command -> . end
    (14) command -> . return
    (15) command -> . return expression
    (16) command -> . continue
    (17) command -> . if relexpression then
    (18) command -> . else
    (19) command -> . def ID LPAREN RPAREN
    (20) command -> . def ID LPAREN parlist RPAREN
    (21) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (22) command -> . let ID EQUALS expression
    (23) command -> . let ID EQUALS command
    (24) command -> . let error
    (25) command -> . list ID EQUALS LPAREN parlist RPAREN
    (48) function -> . ID LPAREN parlist RPAREN

    import          shift and go to state 6
    outcsv          shift and go to state 3
    save            shift and go to state 7
    search          shift and go to state 14
    foreach         shift and go to state 5
    end             shift and go to state 12
    return          shift and go to state 9
    continue        shift and go to state 16
    if              shift and go to state 2
    else            shift and go to state 10
    def             shift and go to state 19
    connect         shift and go to state 1
    let             shift and go to state 11
    list            shift and go to state 15
    ID              shift and go to state 13

    function                       shift and go to state 34
    command                        shift and go to state 35

state 5

    (11) command -> foreach . ID in ID
    (12) command -> foreach . ID COMMA ID in ID

    ID              shift and go to state 36


state 6

    (6) command -> import . STRING

    STRING          shift and go to state 37


state 7

    (8) command -> save . ID in ID
    (9) command -> save . LPAREN parlist RPAREN in ID

    ID              shift and go to state 39
    LPAREN          shift and go to state 38


state 8

    (4) program -> function .

    import          reduce using rule 4 (program -> function .)
    outcsv          reduce using rule 4 (program -> function .)
    save            reduce using rule 4 (program -> function .)
    search          reduce using rule 4 (program -> function .)
    foreach         reduce using rule 4 (program -> function .)
    end             reduce using rule 4 (program -> function .)
    return          reduce using rule 4 (program -> function .)
    continue        reduce using rule 4 (program -> function .)
    if              reduce using rule 4 (program -> function .)
    else            reduce using rule 4 (program -> function .)
    def             reduce using rule 4 (program -> function .)
    connect         reduce using rule 4 (program -> function .)
    let             reduce using rule 4 (program -> function .)
    list            reduce using rule 4 (program -> function .)
    ID              reduce using rule 4 (program -> function .)
    $end            reduce using rule 4 (program -> function .)


state 9

    (14) command -> return .
    (15) command -> return . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

  ! shift/reduce conflict for ID resolved as shift
    import          reduce using rule 14 (command -> return .)
    outcsv          reduce using rule 14 (command -> return .)
    save            reduce using rule 14 (command -> return .)
    search          reduce using rule 14 (command -> return .)
    foreach         reduce using rule 14 (command -> return .)
    end             reduce using rule 14 (command -> return .)
    return          reduce using rule 14 (command -> return .)
    continue        reduce using rule 14 (command -> return .)
    if              reduce using rule 14 (command -> return .)
    else            reduce using rule 14 (command -> return .)
    def             reduce using rule 14 (command -> return .)
    connect         reduce using rule 14 (command -> return .)
    let             reduce using rule 14 (command -> return .)
    list            reduce using rule 14 (command -> return .)
    $end            reduce using rule 14 (command -> return .)
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

  ! ID              [ reduce using rule 14 (command -> return .) ]

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 40

state 10

    (18) command -> else .

    import          reduce using rule 18 (command -> else .)
    outcsv          reduce using rule 18 (command -> else .)
    save            reduce using rule 18 (command -> else .)
    search          reduce using rule 18 (command -> else .)
    foreach         reduce using rule 18 (command -> else .)
    end             reduce using rule 18 (command -> else .)
    return          reduce using rule 18 (command -> else .)
    continue        reduce using rule 18 (command -> else .)
    if              reduce using rule 18 (command -> else .)
    else            reduce using rule 18 (command -> else .)
    def             reduce using rule 18 (command -> else .)
    connect         reduce using rule 18 (command -> else .)
    let             reduce using rule 18 (command -> else .)
    list            reduce using rule 18 (command -> else .)
    ID              reduce using rule 18 (command -> else .)
    $end            reduce using rule 18 (command -> else .)


state 11

    (22) command -> let . ID EQUALS expression
    (23) command -> let . ID EQUALS command
    (24) command -> let . error

    ID              shift and go to state 42
    error           shift and go to state 41


state 12

    (13) command -> end .

    import          reduce using rule 13 (command -> end .)
    outcsv          reduce using rule 13 (command -> end .)
    save            reduce using rule 13 (command -> end .)
    search          reduce using rule 13 (command -> end .)
    foreach         reduce using rule 13 (command -> end .)
    end             reduce using rule 13 (command -> end .)
    return          reduce using rule 13 (command -> end .)
    continue        reduce using rule 13 (command -> end .)
    if              reduce using rule 13 (command -> end .)
    else            reduce using rule 13 (command -> end .)
    def             reduce using rule 13 (command -> end .)
    connect         reduce using rule 13 (command -> end .)
    let             reduce using rule 13 (command -> end .)
    list            reduce using rule 13 (command -> end .)
    ID              reduce using rule 13 (command -> end .)
    $end            reduce using rule 13 (command -> end .)


state 13

    (48) function -> ID . LPAREN parlist RPAREN

    LPAREN          shift and go to state 43


state 14

    (10) command -> search . ID with ID as sql

    ID              shift and go to state 44


state 15

    (25) command -> list . ID EQUALS LPAREN parlist RPAREN

    ID              shift and go to state 45


state 16

    (16) command -> continue .

    import          reduce using rule 16 (command -> continue .)
    outcsv          reduce using rule 16 (command -> continue .)
    save            reduce using rule 16 (command -> continue .)
    search          reduce using rule 16 (command -> continue .)
    foreach         reduce using rule 16 (command -> continue .)
    end             reduce using rule 16 (command -> continue .)
    return          reduce using rule 16 (command -> continue .)
    continue        reduce using rule 16 (command -> continue .)
    if              reduce using rule 16 (command -> continue .)
    else            reduce using rule 16 (command -> continue .)
    def             reduce using rule 16 (command -> continue .)
    connect         reduce using rule 16 (command -> continue .)
    let             reduce using rule 16 (command -> continue .)
    list            reduce using rule 16 (command -> continue .)
    ID              reduce using rule 16 (command -> continue .)
    $end            reduce using rule 16 (command -> continue .)


state 17

    (2) program -> command .

    import          reduce using rule 2 (program -> command .)
    outcsv          reduce using rule 2 (program -> command .)
    save            reduce using rule 2 (program -> command .)
    search          reduce using rule 2 (program -> command .)
    foreach         reduce using rule 2 (program -> command .)
    end             reduce using rule 2 (program -> command .)
    return          reduce using rule 2 (program -> command .)
    continue        reduce using rule 2 (program -> command .)
    if              reduce using rule 2 (program -> command .)
    else            reduce using rule 2 (program -> command .)
    def             reduce using rule 2 (program -> command .)
    connect         reduce using rule 2 (program -> command .)
    let             reduce using rule 2 (program -> command .)
    list            reduce using rule 2 (program -> command .)
    ID              reduce using rule 2 (program -> command .)
    $end            reduce using rule 2 (program -> command .)


state 18

    (5) program -> error .

    import          reduce using rule 5 (program -> error .)
    outcsv          reduce using rule 5 (program -> error .)
    save            reduce using rule 5 (program -> error .)
    search          reduce using rule 5 (program -> error .)
    foreach         reduce using rule 5 (program -> error .)
    end             reduce using rule 5 (program -> error .)
    return          reduce using rule 5 (program -> error .)
    continue        reduce using rule 5 (program -> error .)
    if              reduce using rule 5 (program -> error .)
    else            reduce using rule 5 (program -> error .)
    def             reduce using rule 5 (program -> error .)
    connect         reduce using rule 5 (program -> error .)
    let             reduce using rule 5 (program -> error .)
    list            reduce using rule 5 (program -> error .)
    ID              reduce using rule 5 (program -> error .)
    $end            reduce using rule 5 (program -> error .)


state 19

    (19) command -> def . ID LPAREN RPAREN
    (20) command -> def . ID LPAREN parlist RPAREN

    ID              shift and go to state 46


state 20

    (21) command -> connect ID . EQUALS DBPROVIDER LPAREN STRING RPAREN

    EQUALS          shift and go to state 47


state 21

    (35) expression -> MINUS . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 48

state 22

    (34) expression -> STRING .

    PLUS            reduce using rule 34 (expression -> STRING .)
    MINUS           reduce using rule 34 (expression -> STRING .)
    MULTIPLY        reduce using rule 34 (expression -> STRING .)
    DIVIDE          reduce using rule 34 (expression -> STRING .)
    POWER           reduce using rule 34 (expression -> STRING .)
    LT              reduce using rule 34 (expression -> STRING .)
    LE              reduce using rule 34 (expression -> STRING .)
    GT              reduce using rule 34 (expression -> STRING .)
    GE              reduce using rule 34 (expression -> STRING .)
    EQUALS          reduce using rule 34 (expression -> STRING .)
    NE              reduce using rule 34 (expression -> STRING .)
    import          reduce using rule 34 (expression -> STRING .)
    outcsv          reduce using rule 34 (expression -> STRING .)
    save            reduce using rule 34 (expression -> STRING .)
    search          reduce using rule 34 (expression -> STRING .)
    foreach         reduce using rule 34 (expression -> STRING .)
    end             reduce using rule 34 (expression -> STRING .)
    return          reduce using rule 34 (expression -> STRING .)
    continue        reduce using rule 34 (expression -> STRING .)
    if              reduce using rule 34 (expression -> STRING .)
    else            reduce using rule 34 (expression -> STRING .)
    def             reduce using rule 34 (expression -> STRING .)
    connect         reduce using rule 34 (expression -> STRING .)
    let             reduce using rule 34 (expression -> STRING .)
    list            reduce using rule 34 (expression -> STRING .)
    ID              reduce using rule 34 (expression -> STRING .)
    $end            reduce using rule 34 (expression -> STRING .)
    RPAREN          reduce using rule 34 (expression -> STRING .)
    COMMA           reduce using rule 34 (expression -> STRING .)
    then            reduce using rule 34 (expression -> STRING .)


state 23

    (30) expression -> dbvariable .

    PLUS            reduce using rule 30 (expression -> dbvariable .)
    MINUS           reduce using rule 30 (expression -> dbvariable .)
    MULTIPLY        reduce using rule 30 (expression -> dbvariable .)
    DIVIDE          reduce using rule 30 (expression -> dbvariable .)
    POWER           reduce using rule 30 (expression -> dbvariable .)
    LT              reduce using rule 30 (expression -> dbvariable .)
    LE              reduce using rule 30 (expression -> dbvariable .)
    GT              reduce using rule 30 (expression -> dbvariable .)
    GE              reduce using rule 30 (expression -> dbvariable .)
    EQUALS          reduce using rule 30 (expression -> dbvariable .)
    NE              reduce using rule 30 (expression -> dbvariable .)
    import          reduce using rule 30 (expression -> dbvariable .)
    outcsv          reduce using rule 30 (expression -> dbvariable .)
    save            reduce using rule 30 (expression -> dbvariable .)
    search          reduce using rule 30 (expression -> dbvariable .)
    foreach         reduce using rule 30 (expression -> dbvariable .)
    end             reduce using rule 30 (expression -> dbvariable .)
    return          reduce using rule 30 (expression -> dbvariable .)
    continue        reduce using rule 30 (expression -> dbvariable .)
    if              reduce using rule 30 (expression -> dbvariable .)
    else            reduce using rule 30 (expression -> dbvariable .)
    def             reduce using rule 30 (expression -> dbvariable .)
    connect         reduce using rule 30 (expression -> dbvariable .)
    let             reduce using rule 30 (expression -> dbvariable .)
    list            reduce using rule 30 (expression -> dbvariable .)
    ID              reduce using rule 30 (expression -> dbvariable .)
    $end            reduce using rule 30 (expression -> dbvariable .)
    RPAREN          reduce using rule 30 (expression -> dbvariable .)
    COMMA           reduce using rule 30 (expression -> dbvariable .)
    then            reduce using rule 30 (expression -> dbvariable .)


state 24

    (50) dbvariable -> DBID .

    PLUS            reduce using rule 50 (dbvariable -> DBID .)
    MINUS           reduce using rule 50 (dbvariable -> DBID .)
    MULTIPLY        reduce using rule 50 (dbvariable -> DBID .)
    DIVIDE          reduce using rule 50 (dbvariable -> DBID .)
    POWER           reduce using rule 50 (dbvariable -> DBID .)
    import          reduce using rule 50 (dbvariable -> DBID .)
    outcsv          reduce using rule 50 (dbvariable -> DBID .)
    save            reduce using rule 50 (dbvariable -> DBID .)
    search          reduce using rule 50 (dbvariable -> DBID .)
    foreach         reduce using rule 50 (dbvariable -> DBID .)
    end             reduce using rule 50 (dbvariable -> DBID .)
    return          reduce using rule 50 (dbvariable -> DBID .)
    continue        reduce using rule 50 (dbvariable -> DBID .)
    if              reduce using rule 50 (dbvariable -> DBID .)
    else            reduce using rule 50 (dbvariable -> DBID .)
    def             reduce using rule 50 (dbvariable -> DBID .)
    connect         reduce using rule 50 (dbvariable -> DBID .)
    let             reduce using rule 50 (dbvariable -> DBID .)
    list            reduce using rule 50 (dbvariable -> DBID .)
    ID              reduce using rule 50 (dbvariable -> DBID .)
    $end            reduce using rule 50 (dbvariable -> DBID .)
    LT              reduce using rule 50 (dbvariable -> DBID .)
    LE              reduce using rule 50 (dbvariable -> DBID .)
    GT              reduce using rule 50 (dbvariable -> DBID .)
    GE              reduce using rule 50 (dbvariable -> DBID .)
    EQUALS          reduce using rule 50 (dbvariable -> DBID .)
    NE              reduce using rule 50 (dbvariable -> DBID .)
    RPAREN          reduce using rule 50 (dbvariable -> DBID .)
    COMMA           reduce using rule 50 (dbvariable -> DBID .)
    then            reduce using rule 50 (dbvariable -> DBID .)


state 25

    (32) expression -> INTEGER .

    PLUS            reduce using rule 32 (expression -> INTEGER .)
    MINUS           reduce using rule 32 (expression -> INTEGER .)
    MULTIPLY        reduce using rule 32 (expression -> INTEGER .)
    DIVIDE          reduce using rule 32 (expression -> INTEGER .)
    POWER           reduce using rule 32 (expression -> INTEGER .)
    LT              reduce using rule 32 (expression -> INTEGER .)
    LE              reduce using rule 32 (expression -> INTEGER .)
    GT              reduce using rule 32 (expression -> INTEGER .)
    GE              reduce using rule 32 (expression -> INTEGER .)
    EQUALS          reduce using rule 32 (expression -> INTEGER .)
    NE              reduce using rule 32 (expression -> INTEGER .)
    import          reduce using rule 32 (expression -> INTEGER .)
    outcsv          reduce using rule 32 (expression -> INTEGER .)
    save            reduce using rule 32 (expression -> INTEGER .)
    search          reduce using rule 32 (expression -> INTEGER .)
    foreach         reduce using rule 32 (expression -> INTEGER .)
    end             reduce using rule 32 (expression -> INTEGER .)
    return          reduce using rule 32 (expression -> INTEGER .)
    continue        reduce using rule 32 (expression -> INTEGER .)
    if              reduce using rule 32 (expression -> INTEGER .)
    else            reduce using rule 32 (expression -> INTEGER .)
    def             reduce using rule 32 (expression -> INTEGER .)
    connect         reduce using rule 32 (expression -> INTEGER .)
    let             reduce using rule 32 (expression -> INTEGER .)
    list            reduce using rule 32 (expression -> INTEGER .)
    ID              reduce using rule 32 (expression -> INTEGER .)
    $end            reduce using rule 32 (expression -> INTEGER .)
    RPAREN          reduce using rule 32 (expression -> INTEGER .)
    COMMA           reduce using rule 32 (expression -> INTEGER .)
    then            reduce using rule 32 (expression -> INTEGER .)


state 26

    (31) expression -> function .

    PLUS            reduce using rule 31 (expression -> function .)
    MINUS           reduce using rule 31 (expression -> function .)
    MULTIPLY        reduce using rule 31 (expression -> function .)
    DIVIDE          reduce using rule 31 (expression -> function .)
    POWER           reduce using rule 31 (expression -> function .)
    LT              reduce using rule 31 (expression -> function .)
    LE              reduce using rule 31 (expression -> function .)
    GT              reduce using rule 31 (expression -> function .)
    GE              reduce using rule 31 (expression -> function .)
    EQUALS          reduce using rule 31 (expression -> function .)
    NE              reduce using rule 31 (expression -> function .)
    import          reduce using rule 31 (expression -> function .)
    outcsv          reduce using rule 31 (expression -> function .)
    save            reduce using rule 31 (expression -> function .)
    search          reduce using rule 31 (expression -> function .)
    foreach         reduce using rule 31 (expression -> function .)
    end             reduce using rule 31 (expression -> function .)
    return          reduce using rule 31 (expression -> function .)
    continue        reduce using rule 31 (expression -> function .)
    if              reduce using rule 31 (expression -> function .)
    else            reduce using rule 31 (expression -> function .)
    def             reduce using rule 31 (expression -> function .)
    connect         reduce using rule 31 (expression -> function .)
    let             reduce using rule 31 (expression -> function .)
    list            reduce using rule 31 (expression -> function .)
    ID              reduce using rule 31 (expression -> function .)
    $end            reduce using rule 31 (expression -> function .)
    RPAREN          reduce using rule 31 (expression -> function .)
    COMMA           reduce using rule 31 (expression -> function .)
    then            reduce using rule 31 (expression -> function .)


state 27

    (17) command -> if relexpression . then

    then            shift and go to state 49


state 28

    (36) expression -> LPAREN . expression RPAREN
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 50

state 29

    (29) expression -> variable .

    PLUS            reduce using rule 29 (expression -> variable .)
    MINUS           reduce using rule 29 (expression -> variable .)
    MULTIPLY        reduce using rule 29 (expression -> variable .)
    DIVIDE          reduce using rule 29 (expression -> variable .)
    POWER           reduce using rule 29 (expression -> variable .)
    LT              reduce using rule 29 (expression -> variable .)
    LE              reduce using rule 29 (expression -> variable .)
    GT              reduce using rule 29 (expression -> variable .)
    GE              reduce using rule 29 (expression -> variable .)
    EQUALS          reduce using rule 29 (expression -> variable .)
    NE              reduce using rule 29 (expression -> variable .)
    import          reduce using rule 29 (expression -> variable .)
    outcsv          reduce using rule 29 (expression -> variable .)
    save            reduce using rule 29 (expression -> variable .)
    search          reduce using rule 29 (expression -> variable .)
    foreach         reduce using rule 29 (expression -> variable .)
    end             reduce using rule 29 (expression -> variable .)
    return          reduce using rule 29 (expression -> variable .)
    continue        reduce using rule 29 (expression -> variable .)
    if              reduce using rule 29 (expression -> variable .)
    else            reduce using rule 29 (expression -> variable .)
    def             reduce using rule 29 (expression -> variable .)
    connect         reduce using rule 29 (expression -> variable .)
    let             reduce using rule 29 (expression -> variable .)
    list            reduce using rule 29 (expression -> variable .)
    ID              reduce using rule 29 (expression -> variable .)
    $end            reduce using rule 29 (expression -> variable .)
    RPAREN          reduce using rule 29 (expression -> variable .)
    COMMA           reduce using rule 29 (expression -> variable .)
    then            reduce using rule 29 (expression -> variable .)


state 30

    (49) variable -> ID .
    (48) function -> ID . LPAREN parlist RPAREN

    PLUS            reduce using rule 49 (variable -> ID .)
    MINUS           reduce using rule 49 (variable -> ID .)
    MULTIPLY        reduce using rule 49 (variable -> ID .)
    DIVIDE          reduce using rule 49 (variable -> ID .)
    POWER           reduce using rule 49 (variable -> ID .)
    RPAREN          reduce using rule 49 (variable -> ID .)
    COMMA           reduce using rule 49 (variable -> ID .)
    LT              reduce using rule 49 (variable -> ID .)
    LE              reduce using rule 49 (variable -> ID .)
    GT              reduce using rule 49 (variable -> ID .)
    GE              reduce using rule 49 (variable -> ID .)
    EQUALS          reduce using rule 49 (variable -> ID .)
    NE              reduce using rule 49 (variable -> ID .)
    then            reduce using rule 49 (variable -> ID .)
    import          reduce using rule 49 (variable -> ID .)
    outcsv          reduce using rule 49 (variable -> ID .)
    save            reduce using rule 49 (variable -> ID .)
    search          reduce using rule 49 (variable -> ID .)
    foreach         reduce using rule 49 (variable -> ID .)
    end             reduce using rule 49 (variable -> ID .)
    return          reduce using rule 49 (variable -> ID .)
    continue        reduce using rule 49 (variable -> ID .)
    if              reduce using rule 49 (variable -> ID .)
    else            reduce using rule 49 (variable -> ID .)
    def             reduce using rule 49 (variable -> ID .)
    connect         reduce using rule 49 (variable -> ID .)
    let             reduce using rule 49 (variable -> ID .)
    list            reduce using rule 49 (variable -> ID .)
    ID              reduce using rule 49 (variable -> ID .)
    $end            reduce using rule 49 (variable -> ID .)
    LPAREN          shift and go to state 43


state 31

    (33) expression -> FLOAT .

    PLUS            reduce using rule 33 (expression -> FLOAT .)
    MINUS           reduce using rule 33 (expression -> FLOAT .)
    MULTIPLY        reduce using rule 33 (expression -> FLOAT .)
    DIVIDE          reduce using rule 33 (expression -> FLOAT .)
    POWER           reduce using rule 33 (expression -> FLOAT .)
    LT              reduce using rule 33 (expression -> FLOAT .)
    LE              reduce using rule 33 (expression -> FLOAT .)
    GT              reduce using rule 33 (expression -> FLOAT .)
    GE              reduce using rule 33 (expression -> FLOAT .)
    EQUALS          reduce using rule 33 (expression -> FLOAT .)
    NE              reduce using rule 33 (expression -> FLOAT .)
    import          reduce using rule 33 (expression -> FLOAT .)
    outcsv          reduce using rule 33 (expression -> FLOAT .)
    save            reduce using rule 33 (expression -> FLOAT .)
    search          reduce using rule 33 (expression -> FLOAT .)
    foreach         reduce using rule 33 (expression -> FLOAT .)
    end             reduce using rule 33 (expression -> FLOAT .)
    return          reduce using rule 33 (expression -> FLOAT .)
    continue        reduce using rule 33 (expression -> FLOAT .)
    if              reduce using rule 33 (expression -> FLOAT .)
    else            reduce using rule 33 (expression -> FLOAT .)
    def             reduce using rule 33 (expression -> FLOAT .)
    connect         reduce using rule 33 (expression -> FLOAT .)
    let             reduce using rule 33 (expression -> FLOAT .)
    list            reduce using rule 33 (expression -> FLOAT .)
    ID              reduce using rule 33 (expression -> FLOAT .)
    $end            reduce using rule 33 (expression -> FLOAT .)
    RPAREN          reduce using rule 33 (expression -> FLOAT .)
    COMMA           reduce using rule 33 (expression -> FLOAT .)
    then            reduce using rule 33 (expression -> FLOAT .)


state 32

    (42) relexpression -> expression . LT expression
    (43) relexpression -> expression . LE expression
    (44) relexpression -> expression . GT expression
    (45) relexpression -> expression . GE expression
    (46) relexpression -> expression . EQUALS expression
    (47) relexpression -> expression . NE expression
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    LT              shift and go to state 57
    LE              shift and go to state 51
    GT              shift and go to state 58
    GE              shift and go to state 52
    EQUALS          shift and go to state 55
    NE              shift and go to state 56
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 33

    (7) command -> outcsv ID . in STRING

    in              shift and go to state 62


state 34

    (3) program -> program function .

    import          reduce using rule 3 (program -> program function .)
    outcsv          reduce using rule 3 (program -> program function .)
    save            reduce using rule 3 (program -> program function .)
    search          reduce using rule 3 (program -> program function .)
    foreach         reduce using rule 3 (program -> program function .)
    end             reduce using rule 3 (program -> program function .)
    return          reduce using rule 3 (program -> program function .)
    continue        reduce using rule 3 (program -> program function .)
    if              reduce using rule 3 (program -> program function .)
    else            reduce using rule 3 (program -> program function .)
    def             reduce using rule 3 (program -> program function .)
    connect         reduce using rule 3 (program -> program function .)
    let             reduce using rule 3 (program -> program function .)
    list            reduce using rule 3 (program -> program function .)
    ID              reduce using rule 3 (program -> program function .)
    $end            reduce using rule 3 (program -> program function .)


state 35

    (1) program -> program command .

    import          reduce using rule 1 (program -> program command .)
    outcsv          reduce using rule 1 (program -> program command .)
    save            reduce using rule 1 (program -> program command .)
    search          reduce using rule 1 (program -> program command .)
    foreach         reduce using rule 1 (program -> program command .)
    end             reduce using rule 1 (program -> program command .)
    return          reduce using rule 1 (program -> program command .)
    continue        reduce using rule 1 (program -> program command .)
    if              reduce using rule 1 (program -> program command .)
    else            reduce using rule 1 (program -> program command .)
    def             reduce using rule 1 (program -> program command .)
    connect         reduce using rule 1 (program -> program command .)
    let             reduce using rule 1 (program -> program command .)
    list            reduce using rule 1 (program -> program command .)
    ID              reduce using rule 1 (program -> program command .)
    $end            reduce using rule 1 (program -> program command .)


state 36

    (11) command -> foreach ID . in ID
    (12) command -> foreach ID . COMMA ID in ID

    in              shift and go to state 63
    COMMA           shift and go to state 64


state 37

    (6) command -> import STRING .

    import          reduce using rule 6 (command -> import STRING .)
    outcsv          reduce using rule 6 (command -> import STRING .)
    save            reduce using rule 6 (command -> import STRING .)
    search          reduce using rule 6 (command -> import STRING .)
    foreach         reduce using rule 6 (command -> import STRING .)
    end             reduce using rule 6 (command -> import STRING .)
    return          reduce using rule 6 (command -> import STRING .)
    continue        reduce using rule 6 (command -> import STRING .)
    if              reduce using rule 6 (command -> import STRING .)
    else            reduce using rule 6 (command -> import STRING .)
    def             reduce using rule 6 (command -> import STRING .)
    connect         reduce using rule 6 (command -> import STRING .)
    let             reduce using rule 6 (command -> import STRING .)
    list            reduce using rule 6 (command -> import STRING .)
    ID              reduce using rule 6 (command -> import STRING .)
    $end            reduce using rule 6 (command -> import STRING .)


state 38

    (9) command -> save LPAREN . parlist RPAREN in ID
    (51) parlist -> . parlist COMMA expression
    (52) parlist -> . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 66
    parlist                        shift and go to state 65

state 39

    (8) command -> save ID . in ID

    in              shift and go to state 67


state 40

    (15) command -> return expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    import          reduce using rule 15 (command -> return expression .)
    outcsv          reduce using rule 15 (command -> return expression .)
    save            reduce using rule 15 (command -> return expression .)
    search          reduce using rule 15 (command -> return expression .)
    foreach         reduce using rule 15 (command -> return expression .)
    end             reduce using rule 15 (command -> return expression .)
    return          reduce using rule 15 (command -> return expression .)
    continue        reduce using rule 15 (command -> return expression .)
    if              reduce using rule 15 (command -> return expression .)
    else            reduce using rule 15 (command -> return expression .)
    def             reduce using rule 15 (command -> return expression .)
    connect         reduce using rule 15 (command -> return expression .)
    let             reduce using rule 15 (command -> return expression .)
    list            reduce using rule 15 (command -> return expression .)
    ID              reduce using rule 15 (command -> return expression .)
    $end            reduce using rule 15 (command -> return expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 41

    (24) command -> let error .

    import          reduce using rule 24 (command -> let error .)
    outcsv          reduce using rule 24 (command -> let error .)
    save            reduce using rule 24 (command -> let error .)
    search          reduce using rule 24 (command -> let error .)
    foreach         reduce using rule 24 (command -> let error .)
    end             reduce using rule 24 (command -> let error .)
    return          reduce using rule 24 (command -> let error .)
    continue        reduce using rule 24 (command -> let error .)
    if              reduce using rule 24 (command -> let error .)
    else            reduce using rule 24 (command -> let error .)
    def             reduce using rule 24 (command -> let error .)
    connect         reduce using rule 24 (command -> let error .)
    let             reduce using rule 24 (command -> let error .)
    list            reduce using rule 24 (command -> let error .)
    ID              reduce using rule 24 (command -> let error .)
    $end            reduce using rule 24 (command -> let error .)


state 42

    (22) command -> let ID . EQUALS expression
    (23) command -> let ID . EQUALS command

    EQUALS          shift and go to state 68


state 43

    (48) function -> ID LPAREN . parlist RPAREN
    (51) parlist -> . parlist COMMA expression
    (52) parlist -> . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 66
    parlist                        shift and go to state 69

state 44

    (10) command -> search ID . with ID as sql

    with            shift and go to state 70


state 45

    (25) command -> list ID . EQUALS LPAREN parlist RPAREN

    EQUALS          shift and go to state 71


state 46

    (19) command -> def ID . LPAREN RPAREN
    (20) command -> def ID . LPAREN parlist RPAREN

    LPAREN          shift and go to state 72


state 47

    (21) command -> connect ID EQUALS . DBPROVIDER LPAREN STRING RPAREN

    DBPROVIDER      shift and go to state 73


state 48

    (35) expression -> MINUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 35 (expression -> MINUS expression .)
    MINUS           reduce using rule 35 (expression -> MINUS expression .)
    MULTIPLY        reduce using rule 35 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 35 (expression -> MINUS expression .)
    POWER           reduce using rule 35 (expression -> MINUS expression .)
    LT              reduce using rule 35 (expression -> MINUS expression .)
    LE              reduce using rule 35 (expression -> MINUS expression .)
    GT              reduce using rule 35 (expression -> MINUS expression .)
    GE              reduce using rule 35 (expression -> MINUS expression .)
    EQUALS          reduce using rule 35 (expression -> MINUS expression .)
    NE              reduce using rule 35 (expression -> MINUS expression .)
    import          reduce using rule 35 (expression -> MINUS expression .)
    outcsv          reduce using rule 35 (expression -> MINUS expression .)
    save            reduce using rule 35 (expression -> MINUS expression .)
    search          reduce using rule 35 (expression -> MINUS expression .)
    foreach         reduce using rule 35 (expression -> MINUS expression .)
    end             reduce using rule 35 (expression -> MINUS expression .)
    return          reduce using rule 35 (expression -> MINUS expression .)
    continue        reduce using rule 35 (expression -> MINUS expression .)
    if              reduce using rule 35 (expression -> MINUS expression .)
    else            reduce using rule 35 (expression -> MINUS expression .)
    def             reduce using rule 35 (expression -> MINUS expression .)
    connect         reduce using rule 35 (expression -> MINUS expression .)
    let             reduce using rule 35 (expression -> MINUS expression .)
    list            reduce using rule 35 (expression -> MINUS expression .)
    ID              reduce using rule 35 (expression -> MINUS expression .)
    $end            reduce using rule 35 (expression -> MINUS expression .)
    RPAREN          reduce using rule 35 (expression -> MINUS expression .)
    COMMA           reduce using rule 35 (expression -> MINUS expression .)
    then            reduce using rule 35 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MULTIPLY        [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 53 ]
  ! POWER           [ shift and go to state 54 ]


state 49

    (17) command -> if relexpression then .

    import          reduce using rule 17 (command -> if relexpression then .)
    outcsv          reduce using rule 17 (command -> if relexpression then .)
    save            reduce using rule 17 (command -> if relexpression then .)
    search          reduce using rule 17 (command -> if relexpression then .)
    foreach         reduce using rule 17 (command -> if relexpression then .)
    end             reduce using rule 17 (command -> if relexpression then .)
    return          reduce using rule 17 (command -> if relexpression then .)
    continue        reduce using rule 17 (command -> if relexpression then .)
    if              reduce using rule 17 (command -> if relexpression then .)
    else            reduce using rule 17 (command -> if relexpression then .)
    def             reduce using rule 17 (command -> if relexpression then .)
    connect         reduce using rule 17 (command -> if relexpression then .)
    let             reduce using rule 17 (command -> if relexpression then .)
    list            reduce using rule 17 (command -> if relexpression then .)
    ID              reduce using rule 17 (command -> if relexpression then .)
    $end            reduce using rule 17 (command -> if relexpression then .)


state 50

    (36) expression -> LPAREN expression . RPAREN
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          shift and go to state 74
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 51

    (43) relexpression -> expression LE . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 75

state 52

    (45) relexpression -> expression GE . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 76

state 53

    (40) expression -> expression DIVIDE . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 77

state 54

    (41) expression -> expression POWER . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 78

state 55

    (46) relexpression -> expression EQUALS . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 79

state 56

    (47) relexpression -> expression NE . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 80

state 57

    (42) relexpression -> expression LT . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 81

state 58

    (44) relexpression -> expression GT . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 82

state 59

    (37) expression -> expression PLUS . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 83

state 60

    (39) expression -> expression MULTIPLY . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 84

state 61

    (38) expression -> expression MINUS . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 85

state 62

    (7) command -> outcsv ID in . STRING

    STRING          shift and go to state 86


state 63

    (11) command -> foreach ID in . ID

    ID              shift and go to state 87


state 64

    (12) command -> foreach ID COMMA . ID in ID

    ID              shift and go to state 88


state 65

    (9) command -> save LPAREN parlist . RPAREN in ID
    (51) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 89
    COMMA           shift and go to state 90


state 66

    (52) parlist -> expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          reduce using rule 52 (parlist -> expression .)
    COMMA           reduce using rule 52 (parlist -> expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 67

    (8) command -> save ID in . ID

    ID              shift and go to state 91


state 68

    (22) command -> let ID EQUALS . expression
    (23) command -> let ID EQUALS . command
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . search ID with ID as sql
    (11) command -> . foreach ID in ID
    (12) command -> . foreach ID COMMA ID in ID
    (13) command -> . end
    (14) command -> . return
    (15) command -> . return expression
    (16) command -> . continue
    (17) command -> . if relexpression then
    (18) command -> . else
    (19) command -> . def ID LPAREN RPAREN
    (20) command -> . def ID LPAREN parlist RPAREN
    (21) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (22) command -> . let ID EQUALS expression
    (23) command -> . let ID EQUALS command
    (24) command -> . let error
    (25) command -> . list ID EQUALS LPAREN parlist RPAREN
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    import          shift and go to state 6
    outcsv          shift and go to state 3
    save            shift and go to state 7
    search          shift and go to state 14
    foreach         shift and go to state 5
    end             shift and go to state 12
    return          shift and go to state 9
    continue        shift and go to state 16
    if              shift and go to state 2
    else            shift and go to state 10
    def             shift and go to state 19
    connect         shift and go to state 1
    let             shift and go to state 11
    list            shift and go to state 15
    ID              shift and go to state 30
    DBID            shift and go to state 24

    function                       shift and go to state 26
    dbvariable                     shift and go to state 23
    command                        shift and go to state 92
    variable                       shift and go to state 29
    expression                     shift and go to state 93

state 69

    (48) function -> ID LPAREN parlist . RPAREN
    (51) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 94
    COMMA           shift and go to state 90


state 70

    (10) command -> search ID with . ID as sql

    ID              shift and go to state 95


state 71

    (25) command -> list ID EQUALS . LPAREN parlist RPAREN

    LPAREN          shift and go to state 96


state 72

    (19) command -> def ID LPAREN . RPAREN
    (20) command -> def ID LPAREN . parlist RPAREN
    (51) parlist -> . parlist COMMA expression
    (52) parlist -> . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    RPAREN          shift and go to state 97
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 66
    parlist                        shift and go to state 98

state 73

    (21) command -> connect ID EQUALS DBPROVIDER . LPAREN STRING RPAREN

    LPAREN          shift and go to state 99


state 74

    (36) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    POWER           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    import          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    outcsv          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    save            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    search          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    foreach         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    end             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    return          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    continue        reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    if              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    else            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    def             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    connect         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    let             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    list            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    then            reduce using rule 36 (expression -> LPAREN expression RPAREN .)


state 75

    (43) relexpression -> expression LE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 43 (relexpression -> expression LE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 76

    (45) relexpression -> expression GE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 45 (relexpression -> expression GE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 77

    (40) expression -> expression DIVIDE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 40 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 40 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 40 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 40 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 40 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 40 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 40 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    import          reduce using rule 40 (expression -> expression DIVIDE expression .)
    outcsv          reduce using rule 40 (expression -> expression DIVIDE expression .)
    save            reduce using rule 40 (expression -> expression DIVIDE expression .)
    search          reduce using rule 40 (expression -> expression DIVIDE expression .)
    foreach         reduce using rule 40 (expression -> expression DIVIDE expression .)
    end             reduce using rule 40 (expression -> expression DIVIDE expression .)
    return          reduce using rule 40 (expression -> expression DIVIDE expression .)
    continue        reduce using rule 40 (expression -> expression DIVIDE expression .)
    if              reduce using rule 40 (expression -> expression DIVIDE expression .)
    else            reduce using rule 40 (expression -> expression DIVIDE expression .)
    def             reduce using rule 40 (expression -> expression DIVIDE expression .)
    connect         reduce using rule 40 (expression -> expression DIVIDE expression .)
    let             reduce using rule 40 (expression -> expression DIVIDE expression .)
    list            reduce using rule 40 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 40 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 40 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 40 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 40 (expression -> expression DIVIDE expression .)
    then            reduce using rule 40 (expression -> expression DIVIDE expression .)
    POWER           shift and go to state 54

  ! POWER           [ reduce using rule 40 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MULTIPLY        [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 53 ]


state 78

    (41) expression -> expression POWER expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 41 (expression -> expression POWER expression .)
    MINUS           reduce using rule 41 (expression -> expression POWER expression .)
    MULTIPLY        reduce using rule 41 (expression -> expression POWER expression .)
    DIVIDE          reduce using rule 41 (expression -> expression POWER expression .)
    POWER           reduce using rule 41 (expression -> expression POWER expression .)
    LT              reduce using rule 41 (expression -> expression POWER expression .)
    LE              reduce using rule 41 (expression -> expression POWER expression .)
    GT              reduce using rule 41 (expression -> expression POWER expression .)
    GE              reduce using rule 41 (expression -> expression POWER expression .)
    EQUALS          reduce using rule 41 (expression -> expression POWER expression .)
    NE              reduce using rule 41 (expression -> expression POWER expression .)
    import          reduce using rule 41 (expression -> expression POWER expression .)
    outcsv          reduce using rule 41 (expression -> expression POWER expression .)
    save            reduce using rule 41 (expression -> expression POWER expression .)
    search          reduce using rule 41 (expression -> expression POWER expression .)
    foreach         reduce using rule 41 (expression -> expression POWER expression .)
    end             reduce using rule 41 (expression -> expression POWER expression .)
    return          reduce using rule 41 (expression -> expression POWER expression .)
    continue        reduce using rule 41 (expression -> expression POWER expression .)
    if              reduce using rule 41 (expression -> expression POWER expression .)
    else            reduce using rule 41 (expression -> expression POWER expression .)
    def             reduce using rule 41 (expression -> expression POWER expression .)
    connect         reduce using rule 41 (expression -> expression POWER expression .)
    let             reduce using rule 41 (expression -> expression POWER expression .)
    list            reduce using rule 41 (expression -> expression POWER expression .)
    ID              reduce using rule 41 (expression -> expression POWER expression .)
    $end            reduce using rule 41 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 41 (expression -> expression POWER expression .)
    COMMA           reduce using rule 41 (expression -> expression POWER expression .)
    then            reduce using rule 41 (expression -> expression POWER expression .)

  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MULTIPLY        [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 53 ]
  ! POWER           [ shift and go to state 54 ]


state 79

    (46) relexpression -> expression EQUALS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 46 (relexpression -> expression EQUALS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 80

    (47) relexpression -> expression NE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 47 (relexpression -> expression NE expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 81

    (42) relexpression -> expression LT expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 42 (relexpression -> expression LT expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 82

    (44) relexpression -> expression GT expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 44 (relexpression -> expression GT expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 83

    (37) expression -> expression PLUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 37 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 37 (expression -> expression PLUS expression .)
    LT              reduce using rule 37 (expression -> expression PLUS expression .)
    LE              reduce using rule 37 (expression -> expression PLUS expression .)
    GT              reduce using rule 37 (expression -> expression PLUS expression .)
    GE              reduce using rule 37 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 37 (expression -> expression PLUS expression .)
    NE              reduce using rule 37 (expression -> expression PLUS expression .)
    import          reduce using rule 37 (expression -> expression PLUS expression .)
    outcsv          reduce using rule 37 (expression -> expression PLUS expression .)
    save            reduce using rule 37 (expression -> expression PLUS expression .)
    search          reduce using rule 37 (expression -> expression PLUS expression .)
    foreach         reduce using rule 37 (expression -> expression PLUS expression .)
    end             reduce using rule 37 (expression -> expression PLUS expression .)
    return          reduce using rule 37 (expression -> expression PLUS expression .)
    continue        reduce using rule 37 (expression -> expression PLUS expression .)
    if              reduce using rule 37 (expression -> expression PLUS expression .)
    else            reduce using rule 37 (expression -> expression PLUS expression .)
    def             reduce using rule 37 (expression -> expression PLUS expression .)
    connect         reduce using rule 37 (expression -> expression PLUS expression .)
    let             reduce using rule 37 (expression -> expression PLUS expression .)
    list            reduce using rule 37 (expression -> expression PLUS expression .)
    ID              reduce using rule 37 (expression -> expression PLUS expression .)
    $end            reduce using rule 37 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 37 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 37 (expression -> expression PLUS expression .)
    then            reduce using rule 37 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54

  ! MULTIPLY        [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]


state 84

    (39) expression -> expression MULTIPLY expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 39 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 39 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    LT              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    LE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    GT              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    GE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    EQUALS          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    NE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    import          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    outcsv          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    save            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    search          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    foreach         reduce using rule 39 (expression -> expression MULTIPLY expression .)
    end             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    return          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    continue        reduce using rule 39 (expression -> expression MULTIPLY expression .)
    if              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    else            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    def             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    connect         reduce using rule 39 (expression -> expression MULTIPLY expression .)
    let             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    list            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    ID              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    $end            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    COMMA           reduce using rule 39 (expression -> expression MULTIPLY expression .)
    then            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    POWER           shift and go to state 54

  ! POWER           [ reduce using rule 39 (expression -> expression MULTIPLY expression .) ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]
  ! MULTIPLY        [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 53 ]


state 85

    (38) expression -> expression MINUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 38 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 38 (expression -> expression MINUS expression .)
    LT              reduce using rule 38 (expression -> expression MINUS expression .)
    LE              reduce using rule 38 (expression -> expression MINUS expression .)
    GT              reduce using rule 38 (expression -> expression MINUS expression .)
    GE              reduce using rule 38 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 38 (expression -> expression MINUS expression .)
    NE              reduce using rule 38 (expression -> expression MINUS expression .)
    import          reduce using rule 38 (expression -> expression MINUS expression .)
    outcsv          reduce using rule 38 (expression -> expression MINUS expression .)
    save            reduce using rule 38 (expression -> expression MINUS expression .)
    search          reduce using rule 38 (expression -> expression MINUS expression .)
    foreach         reduce using rule 38 (expression -> expression MINUS expression .)
    end             reduce using rule 38 (expression -> expression MINUS expression .)
    return          reduce using rule 38 (expression -> expression MINUS expression .)
    continue        reduce using rule 38 (expression -> expression MINUS expression .)
    if              reduce using rule 38 (expression -> expression MINUS expression .)
    else            reduce using rule 38 (expression -> expression MINUS expression .)
    def             reduce using rule 38 (expression -> expression MINUS expression .)
    connect         reduce using rule 38 (expression -> expression MINUS expression .)
    let             reduce using rule 38 (expression -> expression MINUS expression .)
    list            reduce using rule 38 (expression -> expression MINUS expression .)
    ID              reduce using rule 38 (expression -> expression MINUS expression .)
    $end            reduce using rule 38 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 38 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 38 (expression -> expression MINUS expression .)
    then            reduce using rule 38 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54

  ! MULTIPLY        [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 59 ]
  ! MINUS           [ shift and go to state 61 ]


state 86

    (7) command -> outcsv ID in STRING .

    import          reduce using rule 7 (command -> outcsv ID in STRING .)
    outcsv          reduce using rule 7 (command -> outcsv ID in STRING .)
    save            reduce using rule 7 (command -> outcsv ID in STRING .)
    search          reduce using rule 7 (command -> outcsv ID in STRING .)
    foreach         reduce using rule 7 (command -> outcsv ID in STRING .)
    end             reduce using rule 7 (command -> outcsv ID in STRING .)
    return          reduce using rule 7 (command -> outcsv ID in STRING .)
    continue        reduce using rule 7 (command -> outcsv ID in STRING .)
    if              reduce using rule 7 (command -> outcsv ID in STRING .)
    else            reduce using rule 7 (command -> outcsv ID in STRING .)
    def             reduce using rule 7 (command -> outcsv ID in STRING .)
    connect         reduce using rule 7 (command -> outcsv ID in STRING .)
    let             reduce using rule 7 (command -> outcsv ID in STRING .)
    list            reduce using rule 7 (command -> outcsv ID in STRING .)
    ID              reduce using rule 7 (command -> outcsv ID in STRING .)
    $end            reduce using rule 7 (command -> outcsv ID in STRING .)


state 87

    (11) command -> foreach ID in ID .

    import          reduce using rule 11 (command -> foreach ID in ID .)
    outcsv          reduce using rule 11 (command -> foreach ID in ID .)
    save            reduce using rule 11 (command -> foreach ID in ID .)
    search          reduce using rule 11 (command -> foreach ID in ID .)
    foreach         reduce using rule 11 (command -> foreach ID in ID .)
    end             reduce using rule 11 (command -> foreach ID in ID .)
    return          reduce using rule 11 (command -> foreach ID in ID .)
    continue        reduce using rule 11 (command -> foreach ID in ID .)
    if              reduce using rule 11 (command -> foreach ID in ID .)
    else            reduce using rule 11 (command -> foreach ID in ID .)
    def             reduce using rule 11 (command -> foreach ID in ID .)
    connect         reduce using rule 11 (command -> foreach ID in ID .)
    let             reduce using rule 11 (command -> foreach ID in ID .)
    list            reduce using rule 11 (command -> foreach ID in ID .)
    ID              reduce using rule 11 (command -> foreach ID in ID .)
    $end            reduce using rule 11 (command -> foreach ID in ID .)


state 88

    (12) command -> foreach ID COMMA ID . in ID

    in              shift and go to state 100


state 89

    (9) command -> save LPAREN parlist RPAREN . in ID

    in              shift and go to state 101


state 90

    (51) parlist -> parlist COMMA . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 102

state 91

    (8) command -> save ID in ID .

    import          reduce using rule 8 (command -> save ID in ID .)
    outcsv          reduce using rule 8 (command -> save ID in ID .)
    save            reduce using rule 8 (command -> save ID in ID .)
    search          reduce using rule 8 (command -> save ID in ID .)
    foreach         reduce using rule 8 (command -> save ID in ID .)
    end             reduce using rule 8 (command -> save ID in ID .)
    return          reduce using rule 8 (command -> save ID in ID .)
    continue        reduce using rule 8 (command -> save ID in ID .)
    if              reduce using rule 8 (command -> save ID in ID .)
    else            reduce using rule 8 (command -> save ID in ID .)
    def             reduce using rule 8 (command -> save ID in ID .)
    connect         reduce using rule 8 (command -> save ID in ID .)
    let             reduce using rule 8 (command -> save ID in ID .)
    list            reduce using rule 8 (command -> save ID in ID .)
    ID              reduce using rule 8 (command -> save ID in ID .)
    $end            reduce using rule 8 (command -> save ID in ID .)


state 92

    (23) command -> let ID EQUALS command .

    import          reduce using rule 23 (command -> let ID EQUALS command .)
    outcsv          reduce using rule 23 (command -> let ID EQUALS command .)
    save            reduce using rule 23 (command -> let ID EQUALS command .)
    search          reduce using rule 23 (command -> let ID EQUALS command .)
    foreach         reduce using rule 23 (command -> let ID EQUALS command .)
    end             reduce using rule 23 (command -> let ID EQUALS command .)
    return          reduce using rule 23 (command -> let ID EQUALS command .)
    continue        reduce using rule 23 (command -> let ID EQUALS command .)
    if              reduce using rule 23 (command -> let ID EQUALS command .)
    else            reduce using rule 23 (command -> let ID EQUALS command .)
    def             reduce using rule 23 (command -> let ID EQUALS command .)
    connect         reduce using rule 23 (command -> let ID EQUALS command .)
    let             reduce using rule 23 (command -> let ID EQUALS command .)
    list            reduce using rule 23 (command -> let ID EQUALS command .)
    ID              reduce using rule 23 (command -> let ID EQUALS command .)
    $end            reduce using rule 23 (command -> let ID EQUALS command .)


state 93

    (22) command -> let ID EQUALS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    import          reduce using rule 22 (command -> let ID EQUALS expression .)
    outcsv          reduce using rule 22 (command -> let ID EQUALS expression .)
    save            reduce using rule 22 (command -> let ID EQUALS expression .)
    search          reduce using rule 22 (command -> let ID EQUALS expression .)
    foreach         reduce using rule 22 (command -> let ID EQUALS expression .)
    end             reduce using rule 22 (command -> let ID EQUALS expression .)
    return          reduce using rule 22 (command -> let ID EQUALS expression .)
    continue        reduce using rule 22 (command -> let ID EQUALS expression .)
    if              reduce using rule 22 (command -> let ID EQUALS expression .)
    else            reduce using rule 22 (command -> let ID EQUALS expression .)
    def             reduce using rule 22 (command -> let ID EQUALS expression .)
    connect         reduce using rule 22 (command -> let ID EQUALS expression .)
    let             reduce using rule 22 (command -> let ID EQUALS expression .)
    list            reduce using rule 22 (command -> let ID EQUALS expression .)
    ID              reduce using rule 22 (command -> let ID EQUALS expression .)
    $end            reduce using rule 22 (command -> let ID EQUALS expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 94

    (48) function -> ID LPAREN parlist RPAREN .

    PLUS            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    MINUS           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    MULTIPLY        reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    DIVIDE          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    POWER           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    LT              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    LE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    GT              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    GE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    EQUALS          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    NE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    import          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    save            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    search          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    end             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    return          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    continue        reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    if              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    else            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    def             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    connect         reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    let             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    list            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    ID              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    $end            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    RPAREN          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    COMMA           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    then            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)


state 95

    (10) command -> search ID with ID . as sql

    as              shift and go to state 103


state 96

    (25) command -> list ID EQUALS LPAREN . parlist RPAREN
    (51) parlist -> . parlist COMMA expression
    (52) parlist -> . expression
    (29) expression -> . variable
    (30) expression -> . dbvariable
    (31) expression -> . function
    (32) expression -> . INTEGER
    (33) expression -> . FLOAT
    (34) expression -> . STRING
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (49) variable -> . ID
    (50) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 22
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    dbvariable                     shift and go to state 23
    function                       shift and go to state 26
    expression                     shift and go to state 66
    parlist                        shift and go to state 104

state 97

    (19) command -> def ID LPAREN RPAREN .

    import          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    outcsv          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    save            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    search          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    foreach         reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    end             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    return          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    continue        reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    if              reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    else            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    def             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    connect         reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    let             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    list            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    ID              reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    $end            reduce using rule 19 (command -> def ID LPAREN RPAREN .)


state 98

    (20) command -> def ID LPAREN parlist . RPAREN
    (51) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 105
    COMMA           shift and go to state 90


state 99

    (21) command -> connect ID EQUALS DBPROVIDER LPAREN . STRING RPAREN

    STRING          shift and go to state 106


state 100

    (12) command -> foreach ID COMMA ID in . ID

    ID              shift and go to state 107


state 101

    (9) command -> save LPAREN parlist RPAREN in . ID

    ID              shift and go to state 108


state 102

    (51) parlist -> parlist COMMA expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          reduce using rule 51 (parlist -> parlist COMMA expression .)
    COMMA           reduce using rule 51 (parlist -> parlist COMMA expression .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 61
    MULTIPLY        shift and go to state 60
    DIVIDE          shift and go to state 53
    POWER           shift and go to state 54


state 103

    (10) command -> search ID with ID as . sql
    (26) sql -> . SELECT
    (27) sql -> . INSERT
    (28) sql -> . UPDATE

    SELECT          shift and go to state 112
    INSERT          shift and go to state 109
    UPDATE          shift and go to state 110

    sql                            shift and go to state 111

state 104

    (25) command -> list ID EQUALS LPAREN parlist . RPAREN
    (51) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 113
    COMMA           shift and go to state 90


state 105

    (20) command -> def ID LPAREN parlist RPAREN .

    import          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    save            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    search          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    end             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    return          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    continue        reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    if              reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    else            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    def             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    connect         reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    let             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    list            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    ID              reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    $end            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)


state 106

    (21) command -> connect ID EQUALS DBPROVIDER LPAREN STRING . RPAREN

    RPAREN          shift and go to state 114


state 107

    (12) command -> foreach ID COMMA ID in ID .

    import          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    outcsv          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    save            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    search          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    foreach         reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    end             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    return          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    continue        reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    if              reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    else            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    def             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    connect         reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    let             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    list            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    ID              reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    $end            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)


state 108

    (9) command -> save LPAREN parlist RPAREN in ID .

    import          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    outcsv          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    save            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    search          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    foreach         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    end             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    return          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    continue        reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    if              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    else            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    def             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    connect         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    let             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    list            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    ID              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    $end            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)


state 109

    (27) sql -> INSERT .

    import          reduce using rule 27 (sql -> INSERT .)
    outcsv          reduce using rule 27 (sql -> INSERT .)
    save            reduce using rule 27 (sql -> INSERT .)
    search          reduce using rule 27 (sql -> INSERT .)
    foreach         reduce using rule 27 (sql -> INSERT .)
    end             reduce using rule 27 (sql -> INSERT .)
    return          reduce using rule 27 (sql -> INSERT .)
    continue        reduce using rule 27 (sql -> INSERT .)
    if              reduce using rule 27 (sql -> INSERT .)
    else            reduce using rule 27 (sql -> INSERT .)
    def             reduce using rule 27 (sql -> INSERT .)
    connect         reduce using rule 27 (sql -> INSERT .)
    let             reduce using rule 27 (sql -> INSERT .)
    list            reduce using rule 27 (sql -> INSERT .)
    ID              reduce using rule 27 (sql -> INSERT .)
    $end            reduce using rule 27 (sql -> INSERT .)


state 110

    (28) sql -> UPDATE .

    import          reduce using rule 28 (sql -> UPDATE .)
    outcsv          reduce using rule 28 (sql -> UPDATE .)
    save            reduce using rule 28 (sql -> UPDATE .)
    search          reduce using rule 28 (sql -> UPDATE .)
    foreach         reduce using rule 28 (sql -> UPDATE .)
    end             reduce using rule 28 (sql -> UPDATE .)
    return          reduce using rule 28 (sql -> UPDATE .)
    continue        reduce using rule 28 (sql -> UPDATE .)
    if              reduce using rule 28 (sql -> UPDATE .)
    else            reduce using rule 28 (sql -> UPDATE .)
    def             reduce using rule 28 (sql -> UPDATE .)
    connect         reduce using rule 28 (sql -> UPDATE .)
    let             reduce using rule 28 (sql -> UPDATE .)
    list            reduce using rule 28 (sql -> UPDATE .)
    ID              reduce using rule 28 (sql -> UPDATE .)
    $end            reduce using rule 28 (sql -> UPDATE .)


state 111

    (10) command -> search ID with ID as sql .

    import          reduce using rule 10 (command -> search ID with ID as sql .)
    outcsv          reduce using rule 10 (command -> search ID with ID as sql .)
    save            reduce using rule 10 (command -> search ID with ID as sql .)
    search          reduce using rule 10 (command -> search ID with ID as sql .)
    foreach         reduce using rule 10 (command -> search ID with ID as sql .)
    end             reduce using rule 10 (command -> search ID with ID as sql .)
    return          reduce using rule 10 (command -> search ID with ID as sql .)
    continue        reduce using rule 10 (command -> search ID with ID as sql .)
    if              reduce using rule 10 (command -> search ID with ID as sql .)
    else            reduce using rule 10 (command -> search ID with ID as sql .)
    def             reduce using rule 10 (command -> search ID with ID as sql .)
    connect         reduce using rule 10 (command -> search ID with ID as sql .)
    let             reduce using rule 10 (command -> search ID with ID as sql .)
    list            reduce using rule 10 (command -> search ID with ID as sql .)
    ID              reduce using rule 10 (command -> search ID with ID as sql .)
    $end            reduce using rule 10 (command -> search ID with ID as sql .)


state 112

    (26) sql -> SELECT .

    import          reduce using rule 26 (sql -> SELECT .)
    outcsv          reduce using rule 26 (sql -> SELECT .)
    save            reduce using rule 26 (sql -> SELECT .)
    search          reduce using rule 26 (sql -> SELECT .)
    foreach         reduce using rule 26 (sql -> SELECT .)
    end             reduce using rule 26 (sql -> SELECT .)
    return          reduce using rule 26 (sql -> SELECT .)
    continue        reduce using rule 26 (sql -> SELECT .)
    if              reduce using rule 26 (sql -> SELECT .)
    else            reduce using rule 26 (sql -> SELECT .)
    def             reduce using rule 26 (sql -> SELECT .)
    connect         reduce using rule 26 (sql -> SELECT .)
    let             reduce using rule 26 (sql -> SELECT .)
    list            reduce using rule 26 (sql -> SELECT .)
    ID              reduce using rule 26 (sql -> SELECT .)
    $end            reduce using rule 26 (sql -> SELECT .)


state 113

    (25) command -> list ID EQUALS LPAREN parlist RPAREN .

    import          reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    outcsv          reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    save            reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    search          reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    foreach         reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    end             reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    return          reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    continue        reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    if              reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    else            reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    def             reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    connect         reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    let             reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    list            reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    ID              reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    $end            reduce using rule 25 (command -> list ID EQUALS LPAREN parlist RPAREN .)


state 114

    (21) command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .

    import          reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    outcsv          reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    save            reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    search          reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    foreach         reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    end             reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    return          reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    continue        reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    if              reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    else            reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    def             reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    connect         reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    let             reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    list            reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    ID              reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    $end            reduce using rule 21 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 9 resolved as shift
