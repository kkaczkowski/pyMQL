Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program command
Rule 2     program -> command
Rule 3     program -> program function
Rule 4     program -> function
Rule 5     program -> error
Rule 6     command -> import STRING
Rule 7     command -> outcsv ID in STRING
Rule 8     command -> save ID in ID
Rule 9     command -> save LPAREN parlist RPAREN in ID
Rule 10    command -> print optend
Rule 11    command -> print parlist
Rule 12    command -> search ID with ID as sql
Rule 13    command -> foreach ID in ID
Rule 14    command -> foreach ID COMMA ID in ID
Rule 15    command -> end
Rule 16    command -> return
Rule 17    command -> return expression
Rule 18    command -> continue
Rule 19    command -> if relexpression then
Rule 20    command -> else
Rule 21    command -> def ID LPAREN RPAREN
Rule 22    command -> def ID LPAREN parlist RPAREN
Rule 23    command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
Rule 24    command -> let ID EQUALS expression
Rule 25    command -> let ID EQUALS command
Rule 26    command -> let error
Rule 27    command -> list ID EQUALS LPAREN parlist RPAREN
Rule 28    sql -> SELECT
Rule 29    sql -> INSERT
Rule 30    sql -> UPDATE
Rule 31    expression -> variable
Rule 32    expression -> function
Rule 33    expression -> INTEGER
Rule 34    expression -> FLOAT
Rule 35    expression -> STRING
Rule 36    expression -> MINUS expression
Rule 37    expression -> LPAREN expression RPAREN
Rule 38    expression -> expression PLUS expression
Rule 39    expression -> expression MINUS expression
Rule 40    expression -> expression MULTIPLY expression
Rule 41    expression -> expression DIVIDE expression
Rule 42    expression -> expression POWER expression
Rule 43    relexpression -> expression LT expression
Rule 44    relexpression -> expression LE expression
Rule 45    relexpression -> expression GT expression
Rule 46    relexpression -> expression GE expression
Rule 47    relexpression -> expression EQUALS expression
Rule 48    relexpression -> expression NE expression
Rule 49    function -> ID LPAREN parlist RPAREN
Rule 50    variable -> ID
Rule 51    variable -> DBID
Rule 52    parlist -> parlist COMMA expression
Rule 53    parlist -> expression
Rule 54    optend -> COMMA
Rule 55    optend -> SEMI
Rule 56    optend -> <empty>

Terminals, with rules where they appear

COMMA                : 14 52 54
DBID                 : 51
DBPROVIDER           : 23
DIVIDE               : 41
EQUALS               : 23 24 25 27 47
FLOAT                : 34
GE                   : 46
GT                   : 45
ID                   : 7 8 8 9 12 12 13 13 14 14 14 21 22 23 24 25 27 49 50
INSERT               : 29
INTEGER              : 33
LE                   : 44
LPAREN               : 9 21 22 23 27 37 49
LT                   : 43
MINUS                : 36 39
MULTIPLY             : 40
NE                   : 48
PLUS                 : 38
POWER                : 42
RPAREN               : 9 21 22 23 27 37 49
SELECT               : 28
SEMI                 : 55
STRING               : 6 7 23 35
UPDATE               : 30
as                   : 12
connect              : 23
continue             : 18
def                  : 21 22
else                 : 20
end                  : 15
error                : 5 26
foreach              : 13 14
if                   : 19
import               : 6
in                   : 7 8 9 13 14
let                  : 24 25 26
list                 : 27
outcsv               : 7
print                : 10 11
return               : 16 17
save                 : 8 9
search               : 12
then                 : 19
with                 : 12

Nonterminals, with rules where they appear

command              : 1 2 25
expression           : 17 24 36 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 52 53
function             : 3 4 32
optend               : 10
parlist              : 9 11 22 27 49 52
program              : 1 3 0
relexpression        : 19
sql                  : 12
variable             : 31

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program command
    (2) program -> . command
    (3) program -> . program function
    (4) program -> . function
    (5) program -> . error
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . print optend
    (11) command -> . print parlist
    (12) command -> . search ID with ID as sql
    (13) command -> . foreach ID in ID
    (14) command -> . foreach ID COMMA ID in ID
    (15) command -> . end
    (16) command -> . return
    (17) command -> . return expression
    (18) command -> . continue
    (19) command -> . if relexpression then
    (20) command -> . else
    (21) command -> . def ID LPAREN RPAREN
    (22) command -> . def ID LPAREN parlist RPAREN
    (23) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (24) command -> . let ID EQUALS expression
    (25) command -> . let ID EQUALS command
    (26) command -> . let error
    (27) command -> . list ID EQUALS LPAREN parlist RPAREN
    (49) function -> . ID LPAREN parlist RPAREN

    error           shift and go to state 19
    import          shift and go to state 7
    outcsv          shift and go to state 3
    save            shift and go to state 8
    print           shift and go to state 6
    search          shift and go to state 15
    foreach         shift and go to state 5
    end             shift and go to state 13
    return          shift and go to state 10
    continue        shift and go to state 17
    if              shift and go to state 2
    else            shift and go to state 11
    def             shift and go to state 20
    connect         shift and go to state 1
    let             shift and go to state 12
    list            shift and go to state 16
    ID              shift and go to state 14

    function                       shift and go to state 9
    program                        shift and go to state 4
    command                        shift and go to state 18

state 1

    (23) command -> connect . ID EQUALS DBPROVIDER LPAREN STRING RPAREN

    ID              shift and go to state 21


state 2

    (19) command -> if . relexpression then
    (43) relexpression -> . expression LT expression
    (44) relexpression -> . expression LE expression
    (45) relexpression -> . expression GT expression
    (46) relexpression -> . expression GE expression
    (47) relexpression -> . expression EQUALS expression
    (48) relexpression -> . expression NE expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 32
    relexpression                  shift and go to state 27

state 3

    (7) command -> outcsv . ID in STRING

    ID              shift and go to state 33


state 4

    (0) S' -> program .
    (1) program -> program . command
    (3) program -> program . function
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . print optend
    (11) command -> . print parlist
    (12) command -> . search ID with ID as sql
    (13) command -> . foreach ID in ID
    (14) command -> . foreach ID COMMA ID in ID
    (15) command -> . end
    (16) command -> . return
    (17) command -> . return expression
    (18) command -> . continue
    (19) command -> . if relexpression then
    (20) command -> . else
    (21) command -> . def ID LPAREN RPAREN
    (22) command -> . def ID LPAREN parlist RPAREN
    (23) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (24) command -> . let ID EQUALS expression
    (25) command -> . let ID EQUALS command
    (26) command -> . let error
    (27) command -> . list ID EQUALS LPAREN parlist RPAREN
    (49) function -> . ID LPAREN parlist RPAREN

    import          shift and go to state 7
    outcsv          shift and go to state 3
    save            shift and go to state 8
    print           shift and go to state 6
    search          shift and go to state 15
    foreach         shift and go to state 5
    end             shift and go to state 13
    return          shift and go to state 10
    continue        shift and go to state 17
    if              shift and go to state 2
    else            shift and go to state 11
    def             shift and go to state 20
    connect         shift and go to state 1
    let             shift and go to state 12
    list            shift and go to state 16
    ID              shift and go to state 14

    function                       shift and go to state 34
    command                        shift and go to state 35

state 5

    (13) command -> foreach . ID in ID
    (14) command -> foreach . ID COMMA ID in ID

    ID              shift and go to state 36


state 6

    (10) command -> print . optend
    (11) command -> print . parlist
    (54) optend -> . COMMA
    (55) optend -> . SEMI
    (56) optend -> .
    (52) parlist -> . parlist COMMA expression
    (53) parlist -> . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

  ! shift/reduce conflict for ID resolved as shift
    COMMA           shift and go to state 40
    SEMI            shift and go to state 37
    import          reduce using rule 56 (optend -> .)
    outcsv          reduce using rule 56 (optend -> .)
    save            reduce using rule 56 (optend -> .)
    print           reduce using rule 56 (optend -> .)
    search          reduce using rule 56 (optend -> .)
    foreach         reduce using rule 56 (optend -> .)
    end             reduce using rule 56 (optend -> .)
    return          reduce using rule 56 (optend -> .)
    continue        reduce using rule 56 (optend -> .)
    if              reduce using rule 56 (optend -> .)
    else            reduce using rule 56 (optend -> .)
    def             reduce using rule 56 (optend -> .)
    connect         reduce using rule 56 (optend -> .)
    let             reduce using rule 56 (optend -> .)
    list            reduce using rule 56 (optend -> .)
    $end            reduce using rule 56 (optend -> .)
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

  ! ID              [ reduce using rule 56 (optend -> .) ]

    variable                       shift and go to state 29
    expression                     shift and go to state 41
    function                       shift and go to state 26
    optend                         shift and go to state 38
    parlist                        shift and go to state 39

state 7

    (6) command -> import . STRING

    STRING          shift and go to state 42


state 8

    (8) command -> save . ID in ID
    (9) command -> save . LPAREN parlist RPAREN in ID

    ID              shift and go to state 44
    LPAREN          shift and go to state 43


state 9

    (4) program -> function .

    import          reduce using rule 4 (program -> function .)
    outcsv          reduce using rule 4 (program -> function .)
    save            reduce using rule 4 (program -> function .)
    print           reduce using rule 4 (program -> function .)
    search          reduce using rule 4 (program -> function .)
    foreach         reduce using rule 4 (program -> function .)
    end             reduce using rule 4 (program -> function .)
    return          reduce using rule 4 (program -> function .)
    continue        reduce using rule 4 (program -> function .)
    if              reduce using rule 4 (program -> function .)
    else            reduce using rule 4 (program -> function .)
    def             reduce using rule 4 (program -> function .)
    connect         reduce using rule 4 (program -> function .)
    let             reduce using rule 4 (program -> function .)
    list            reduce using rule 4 (program -> function .)
    ID              reduce using rule 4 (program -> function .)
    $end            reduce using rule 4 (program -> function .)


state 10

    (16) command -> return .
    (17) command -> return . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

  ! shift/reduce conflict for ID resolved as shift
    import          reduce using rule 16 (command -> return .)
    outcsv          reduce using rule 16 (command -> return .)
    save            reduce using rule 16 (command -> return .)
    print           reduce using rule 16 (command -> return .)
    search          reduce using rule 16 (command -> return .)
    foreach         reduce using rule 16 (command -> return .)
    end             reduce using rule 16 (command -> return .)
    return          reduce using rule 16 (command -> return .)
    continue        reduce using rule 16 (command -> return .)
    if              reduce using rule 16 (command -> return .)
    else            reduce using rule 16 (command -> return .)
    def             reduce using rule 16 (command -> return .)
    connect         reduce using rule 16 (command -> return .)
    let             reduce using rule 16 (command -> return .)
    list            reduce using rule 16 (command -> return .)
    $end            reduce using rule 16 (command -> return .)
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

  ! ID              [ reduce using rule 16 (command -> return .) ]

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 45

state 11

    (20) command -> else .

    import          reduce using rule 20 (command -> else .)
    outcsv          reduce using rule 20 (command -> else .)
    save            reduce using rule 20 (command -> else .)
    print           reduce using rule 20 (command -> else .)
    search          reduce using rule 20 (command -> else .)
    foreach         reduce using rule 20 (command -> else .)
    end             reduce using rule 20 (command -> else .)
    return          reduce using rule 20 (command -> else .)
    continue        reduce using rule 20 (command -> else .)
    if              reduce using rule 20 (command -> else .)
    else            reduce using rule 20 (command -> else .)
    def             reduce using rule 20 (command -> else .)
    connect         reduce using rule 20 (command -> else .)
    let             reduce using rule 20 (command -> else .)
    list            reduce using rule 20 (command -> else .)
    ID              reduce using rule 20 (command -> else .)
    $end            reduce using rule 20 (command -> else .)


state 12

    (24) command -> let . ID EQUALS expression
    (25) command -> let . ID EQUALS command
    (26) command -> let . error

    ID              shift and go to state 47
    error           shift and go to state 46


state 13

    (15) command -> end .

    import          reduce using rule 15 (command -> end .)
    outcsv          reduce using rule 15 (command -> end .)
    save            reduce using rule 15 (command -> end .)
    print           reduce using rule 15 (command -> end .)
    search          reduce using rule 15 (command -> end .)
    foreach         reduce using rule 15 (command -> end .)
    end             reduce using rule 15 (command -> end .)
    return          reduce using rule 15 (command -> end .)
    continue        reduce using rule 15 (command -> end .)
    if              reduce using rule 15 (command -> end .)
    else            reduce using rule 15 (command -> end .)
    def             reduce using rule 15 (command -> end .)
    connect         reduce using rule 15 (command -> end .)
    let             reduce using rule 15 (command -> end .)
    list            reduce using rule 15 (command -> end .)
    ID              reduce using rule 15 (command -> end .)
    $end            reduce using rule 15 (command -> end .)


state 14

    (49) function -> ID . LPAREN parlist RPAREN

    LPAREN          shift and go to state 48


state 15

    (12) command -> search . ID with ID as sql

    ID              shift and go to state 49


state 16

    (27) command -> list . ID EQUALS LPAREN parlist RPAREN

    ID              shift and go to state 50


state 17

    (18) command -> continue .

    import          reduce using rule 18 (command -> continue .)
    outcsv          reduce using rule 18 (command -> continue .)
    save            reduce using rule 18 (command -> continue .)
    print           reduce using rule 18 (command -> continue .)
    search          reduce using rule 18 (command -> continue .)
    foreach         reduce using rule 18 (command -> continue .)
    end             reduce using rule 18 (command -> continue .)
    return          reduce using rule 18 (command -> continue .)
    continue        reduce using rule 18 (command -> continue .)
    if              reduce using rule 18 (command -> continue .)
    else            reduce using rule 18 (command -> continue .)
    def             reduce using rule 18 (command -> continue .)
    connect         reduce using rule 18 (command -> continue .)
    let             reduce using rule 18 (command -> continue .)
    list            reduce using rule 18 (command -> continue .)
    ID              reduce using rule 18 (command -> continue .)
    $end            reduce using rule 18 (command -> continue .)


state 18

    (2) program -> command .

    import          reduce using rule 2 (program -> command .)
    outcsv          reduce using rule 2 (program -> command .)
    save            reduce using rule 2 (program -> command .)
    print           reduce using rule 2 (program -> command .)
    search          reduce using rule 2 (program -> command .)
    foreach         reduce using rule 2 (program -> command .)
    end             reduce using rule 2 (program -> command .)
    return          reduce using rule 2 (program -> command .)
    continue        reduce using rule 2 (program -> command .)
    if              reduce using rule 2 (program -> command .)
    else            reduce using rule 2 (program -> command .)
    def             reduce using rule 2 (program -> command .)
    connect         reduce using rule 2 (program -> command .)
    let             reduce using rule 2 (program -> command .)
    list            reduce using rule 2 (program -> command .)
    ID              reduce using rule 2 (program -> command .)
    $end            reduce using rule 2 (program -> command .)


state 19

    (5) program -> error .

    import          reduce using rule 5 (program -> error .)
    outcsv          reduce using rule 5 (program -> error .)
    save            reduce using rule 5 (program -> error .)
    print           reduce using rule 5 (program -> error .)
    search          reduce using rule 5 (program -> error .)
    foreach         reduce using rule 5 (program -> error .)
    end             reduce using rule 5 (program -> error .)
    return          reduce using rule 5 (program -> error .)
    continue        reduce using rule 5 (program -> error .)
    if              reduce using rule 5 (program -> error .)
    else            reduce using rule 5 (program -> error .)
    def             reduce using rule 5 (program -> error .)
    connect         reduce using rule 5 (program -> error .)
    let             reduce using rule 5 (program -> error .)
    list            reduce using rule 5 (program -> error .)
    ID              reduce using rule 5 (program -> error .)
    $end            reduce using rule 5 (program -> error .)


state 20

    (21) command -> def . ID LPAREN RPAREN
    (22) command -> def . ID LPAREN parlist RPAREN

    ID              shift and go to state 51


state 21

    (23) command -> connect ID . EQUALS DBPROVIDER LPAREN STRING RPAREN

    EQUALS          shift and go to state 52


state 22

    (36) expression -> MINUS . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 53

state 23

    (35) expression -> STRING .

    PLUS            reduce using rule 35 (expression -> STRING .)
    MINUS           reduce using rule 35 (expression -> STRING .)
    MULTIPLY        reduce using rule 35 (expression -> STRING .)
    DIVIDE          reduce using rule 35 (expression -> STRING .)
    POWER           reduce using rule 35 (expression -> STRING .)
    then            reduce using rule 35 (expression -> STRING .)
    RPAREN          reduce using rule 35 (expression -> STRING .)
    COMMA           reduce using rule 35 (expression -> STRING .)
    LT              reduce using rule 35 (expression -> STRING .)
    LE              reduce using rule 35 (expression -> STRING .)
    GT              reduce using rule 35 (expression -> STRING .)
    GE              reduce using rule 35 (expression -> STRING .)
    EQUALS          reduce using rule 35 (expression -> STRING .)
    NE              reduce using rule 35 (expression -> STRING .)
    import          reduce using rule 35 (expression -> STRING .)
    outcsv          reduce using rule 35 (expression -> STRING .)
    save            reduce using rule 35 (expression -> STRING .)
    print           reduce using rule 35 (expression -> STRING .)
    search          reduce using rule 35 (expression -> STRING .)
    foreach         reduce using rule 35 (expression -> STRING .)
    end             reduce using rule 35 (expression -> STRING .)
    return          reduce using rule 35 (expression -> STRING .)
    continue        reduce using rule 35 (expression -> STRING .)
    if              reduce using rule 35 (expression -> STRING .)
    else            reduce using rule 35 (expression -> STRING .)
    def             reduce using rule 35 (expression -> STRING .)
    connect         reduce using rule 35 (expression -> STRING .)
    let             reduce using rule 35 (expression -> STRING .)
    list            reduce using rule 35 (expression -> STRING .)
    ID              reduce using rule 35 (expression -> STRING .)
    $end            reduce using rule 35 (expression -> STRING .)


state 24

    (51) variable -> DBID .

    PLUS            reduce using rule 51 (variable -> DBID .)
    MINUS           reduce using rule 51 (variable -> DBID .)
    MULTIPLY        reduce using rule 51 (variable -> DBID .)
    DIVIDE          reduce using rule 51 (variable -> DBID .)
    POWER           reduce using rule 51 (variable -> DBID .)
    LT              reduce using rule 51 (variable -> DBID .)
    LE              reduce using rule 51 (variable -> DBID .)
    GT              reduce using rule 51 (variable -> DBID .)
    GE              reduce using rule 51 (variable -> DBID .)
    EQUALS          reduce using rule 51 (variable -> DBID .)
    NE              reduce using rule 51 (variable -> DBID .)
    COMMA           reduce using rule 51 (variable -> DBID .)
    import          reduce using rule 51 (variable -> DBID .)
    outcsv          reduce using rule 51 (variable -> DBID .)
    save            reduce using rule 51 (variable -> DBID .)
    print           reduce using rule 51 (variable -> DBID .)
    search          reduce using rule 51 (variable -> DBID .)
    foreach         reduce using rule 51 (variable -> DBID .)
    end             reduce using rule 51 (variable -> DBID .)
    return          reduce using rule 51 (variable -> DBID .)
    continue        reduce using rule 51 (variable -> DBID .)
    if              reduce using rule 51 (variable -> DBID .)
    else            reduce using rule 51 (variable -> DBID .)
    def             reduce using rule 51 (variable -> DBID .)
    connect         reduce using rule 51 (variable -> DBID .)
    let             reduce using rule 51 (variable -> DBID .)
    list            reduce using rule 51 (variable -> DBID .)
    ID              reduce using rule 51 (variable -> DBID .)
    $end            reduce using rule 51 (variable -> DBID .)
    RPAREN          reduce using rule 51 (variable -> DBID .)
    then            reduce using rule 51 (variable -> DBID .)


state 25

    (33) expression -> INTEGER .

    PLUS            reduce using rule 33 (expression -> INTEGER .)
    MINUS           reduce using rule 33 (expression -> INTEGER .)
    MULTIPLY        reduce using rule 33 (expression -> INTEGER .)
    DIVIDE          reduce using rule 33 (expression -> INTEGER .)
    POWER           reduce using rule 33 (expression -> INTEGER .)
    then            reduce using rule 33 (expression -> INTEGER .)
    RPAREN          reduce using rule 33 (expression -> INTEGER .)
    COMMA           reduce using rule 33 (expression -> INTEGER .)
    LT              reduce using rule 33 (expression -> INTEGER .)
    LE              reduce using rule 33 (expression -> INTEGER .)
    GT              reduce using rule 33 (expression -> INTEGER .)
    GE              reduce using rule 33 (expression -> INTEGER .)
    EQUALS          reduce using rule 33 (expression -> INTEGER .)
    NE              reduce using rule 33 (expression -> INTEGER .)
    import          reduce using rule 33 (expression -> INTEGER .)
    outcsv          reduce using rule 33 (expression -> INTEGER .)
    save            reduce using rule 33 (expression -> INTEGER .)
    print           reduce using rule 33 (expression -> INTEGER .)
    search          reduce using rule 33 (expression -> INTEGER .)
    foreach         reduce using rule 33 (expression -> INTEGER .)
    end             reduce using rule 33 (expression -> INTEGER .)
    return          reduce using rule 33 (expression -> INTEGER .)
    continue        reduce using rule 33 (expression -> INTEGER .)
    if              reduce using rule 33 (expression -> INTEGER .)
    else            reduce using rule 33 (expression -> INTEGER .)
    def             reduce using rule 33 (expression -> INTEGER .)
    connect         reduce using rule 33 (expression -> INTEGER .)
    let             reduce using rule 33 (expression -> INTEGER .)
    list            reduce using rule 33 (expression -> INTEGER .)
    ID              reduce using rule 33 (expression -> INTEGER .)
    $end            reduce using rule 33 (expression -> INTEGER .)


state 26

    (32) expression -> function .

    PLUS            reduce using rule 32 (expression -> function .)
    MINUS           reduce using rule 32 (expression -> function .)
    MULTIPLY        reduce using rule 32 (expression -> function .)
    DIVIDE          reduce using rule 32 (expression -> function .)
    POWER           reduce using rule 32 (expression -> function .)
    then            reduce using rule 32 (expression -> function .)
    RPAREN          reduce using rule 32 (expression -> function .)
    COMMA           reduce using rule 32 (expression -> function .)
    LT              reduce using rule 32 (expression -> function .)
    LE              reduce using rule 32 (expression -> function .)
    GT              reduce using rule 32 (expression -> function .)
    GE              reduce using rule 32 (expression -> function .)
    EQUALS          reduce using rule 32 (expression -> function .)
    NE              reduce using rule 32 (expression -> function .)
    import          reduce using rule 32 (expression -> function .)
    outcsv          reduce using rule 32 (expression -> function .)
    save            reduce using rule 32 (expression -> function .)
    print           reduce using rule 32 (expression -> function .)
    search          reduce using rule 32 (expression -> function .)
    foreach         reduce using rule 32 (expression -> function .)
    end             reduce using rule 32 (expression -> function .)
    return          reduce using rule 32 (expression -> function .)
    continue        reduce using rule 32 (expression -> function .)
    if              reduce using rule 32 (expression -> function .)
    else            reduce using rule 32 (expression -> function .)
    def             reduce using rule 32 (expression -> function .)
    connect         reduce using rule 32 (expression -> function .)
    let             reduce using rule 32 (expression -> function .)
    list            reduce using rule 32 (expression -> function .)
    ID              reduce using rule 32 (expression -> function .)
    $end            reduce using rule 32 (expression -> function .)


state 27

    (19) command -> if relexpression . then

    then            shift and go to state 54


state 28

    (37) expression -> LPAREN . expression RPAREN
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 55

state 29

    (31) expression -> variable .

    PLUS            reduce using rule 31 (expression -> variable .)
    MINUS           reduce using rule 31 (expression -> variable .)
    MULTIPLY        reduce using rule 31 (expression -> variable .)
    DIVIDE          reduce using rule 31 (expression -> variable .)
    POWER           reduce using rule 31 (expression -> variable .)
    then            reduce using rule 31 (expression -> variable .)
    RPAREN          reduce using rule 31 (expression -> variable .)
    COMMA           reduce using rule 31 (expression -> variable .)
    LT              reduce using rule 31 (expression -> variable .)
    LE              reduce using rule 31 (expression -> variable .)
    GT              reduce using rule 31 (expression -> variable .)
    GE              reduce using rule 31 (expression -> variable .)
    EQUALS          reduce using rule 31 (expression -> variable .)
    NE              reduce using rule 31 (expression -> variable .)
    import          reduce using rule 31 (expression -> variable .)
    outcsv          reduce using rule 31 (expression -> variable .)
    save            reduce using rule 31 (expression -> variable .)
    print           reduce using rule 31 (expression -> variable .)
    search          reduce using rule 31 (expression -> variable .)
    foreach         reduce using rule 31 (expression -> variable .)
    end             reduce using rule 31 (expression -> variable .)
    return          reduce using rule 31 (expression -> variable .)
    continue        reduce using rule 31 (expression -> variable .)
    if              reduce using rule 31 (expression -> variable .)
    else            reduce using rule 31 (expression -> variable .)
    def             reduce using rule 31 (expression -> variable .)
    connect         reduce using rule 31 (expression -> variable .)
    let             reduce using rule 31 (expression -> variable .)
    list            reduce using rule 31 (expression -> variable .)
    ID              reduce using rule 31 (expression -> variable .)
    $end            reduce using rule 31 (expression -> variable .)


state 30

    (50) variable -> ID .
    (49) function -> ID . LPAREN parlist RPAREN

    PLUS            reduce using rule 50 (variable -> ID .)
    MINUS           reduce using rule 50 (variable -> ID .)
    MULTIPLY        reduce using rule 50 (variable -> ID .)
    DIVIDE          reduce using rule 50 (variable -> ID .)
    POWER           reduce using rule 50 (variable -> ID .)
    LT              reduce using rule 50 (variable -> ID .)
    LE              reduce using rule 50 (variable -> ID .)
    GT              reduce using rule 50 (variable -> ID .)
    GE              reduce using rule 50 (variable -> ID .)
    EQUALS          reduce using rule 50 (variable -> ID .)
    NE              reduce using rule 50 (variable -> ID .)
    COMMA           reduce using rule 50 (variable -> ID .)
    import          reduce using rule 50 (variable -> ID .)
    outcsv          reduce using rule 50 (variable -> ID .)
    save            reduce using rule 50 (variable -> ID .)
    print           reduce using rule 50 (variable -> ID .)
    search          reduce using rule 50 (variable -> ID .)
    foreach         reduce using rule 50 (variable -> ID .)
    end             reduce using rule 50 (variable -> ID .)
    return          reduce using rule 50 (variable -> ID .)
    continue        reduce using rule 50 (variable -> ID .)
    if              reduce using rule 50 (variable -> ID .)
    else            reduce using rule 50 (variable -> ID .)
    def             reduce using rule 50 (variable -> ID .)
    connect         reduce using rule 50 (variable -> ID .)
    let             reduce using rule 50 (variable -> ID .)
    list            reduce using rule 50 (variable -> ID .)
    ID              reduce using rule 50 (variable -> ID .)
    $end            reduce using rule 50 (variable -> ID .)
    RPAREN          reduce using rule 50 (variable -> ID .)
    then            reduce using rule 50 (variable -> ID .)
    LPAREN          shift and go to state 48


state 31

    (34) expression -> FLOAT .

    PLUS            reduce using rule 34 (expression -> FLOAT .)
    MINUS           reduce using rule 34 (expression -> FLOAT .)
    MULTIPLY        reduce using rule 34 (expression -> FLOAT .)
    DIVIDE          reduce using rule 34 (expression -> FLOAT .)
    POWER           reduce using rule 34 (expression -> FLOAT .)
    then            reduce using rule 34 (expression -> FLOAT .)
    RPAREN          reduce using rule 34 (expression -> FLOAT .)
    COMMA           reduce using rule 34 (expression -> FLOAT .)
    LT              reduce using rule 34 (expression -> FLOAT .)
    LE              reduce using rule 34 (expression -> FLOAT .)
    GT              reduce using rule 34 (expression -> FLOAT .)
    GE              reduce using rule 34 (expression -> FLOAT .)
    EQUALS          reduce using rule 34 (expression -> FLOAT .)
    NE              reduce using rule 34 (expression -> FLOAT .)
    import          reduce using rule 34 (expression -> FLOAT .)
    outcsv          reduce using rule 34 (expression -> FLOAT .)
    save            reduce using rule 34 (expression -> FLOAT .)
    print           reduce using rule 34 (expression -> FLOAT .)
    search          reduce using rule 34 (expression -> FLOAT .)
    foreach         reduce using rule 34 (expression -> FLOAT .)
    end             reduce using rule 34 (expression -> FLOAT .)
    return          reduce using rule 34 (expression -> FLOAT .)
    continue        reduce using rule 34 (expression -> FLOAT .)
    if              reduce using rule 34 (expression -> FLOAT .)
    else            reduce using rule 34 (expression -> FLOAT .)
    def             reduce using rule 34 (expression -> FLOAT .)
    connect         reduce using rule 34 (expression -> FLOAT .)
    let             reduce using rule 34 (expression -> FLOAT .)
    list            reduce using rule 34 (expression -> FLOAT .)
    ID              reduce using rule 34 (expression -> FLOAT .)
    $end            reduce using rule 34 (expression -> FLOAT .)


state 32

    (43) relexpression -> expression . LT expression
    (44) relexpression -> expression . LE expression
    (45) relexpression -> expression . GT expression
    (46) relexpression -> expression . GE expression
    (47) relexpression -> expression . EQUALS expression
    (48) relexpression -> expression . NE expression
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    LT              shift and go to state 62
    LE              shift and go to state 56
    GT              shift and go to state 63
    GE              shift and go to state 57
    EQUALS          shift and go to state 60
    NE              shift and go to state 61
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 33

    (7) command -> outcsv ID . in STRING

    in              shift and go to state 67


state 34

    (3) program -> program function .

    import          reduce using rule 3 (program -> program function .)
    outcsv          reduce using rule 3 (program -> program function .)
    save            reduce using rule 3 (program -> program function .)
    print           reduce using rule 3 (program -> program function .)
    search          reduce using rule 3 (program -> program function .)
    foreach         reduce using rule 3 (program -> program function .)
    end             reduce using rule 3 (program -> program function .)
    return          reduce using rule 3 (program -> program function .)
    continue        reduce using rule 3 (program -> program function .)
    if              reduce using rule 3 (program -> program function .)
    else            reduce using rule 3 (program -> program function .)
    def             reduce using rule 3 (program -> program function .)
    connect         reduce using rule 3 (program -> program function .)
    let             reduce using rule 3 (program -> program function .)
    list            reduce using rule 3 (program -> program function .)
    ID              reduce using rule 3 (program -> program function .)
    $end            reduce using rule 3 (program -> program function .)


state 35

    (1) program -> program command .

    import          reduce using rule 1 (program -> program command .)
    outcsv          reduce using rule 1 (program -> program command .)
    save            reduce using rule 1 (program -> program command .)
    print           reduce using rule 1 (program -> program command .)
    search          reduce using rule 1 (program -> program command .)
    foreach         reduce using rule 1 (program -> program command .)
    end             reduce using rule 1 (program -> program command .)
    return          reduce using rule 1 (program -> program command .)
    continue        reduce using rule 1 (program -> program command .)
    if              reduce using rule 1 (program -> program command .)
    else            reduce using rule 1 (program -> program command .)
    def             reduce using rule 1 (program -> program command .)
    connect         reduce using rule 1 (program -> program command .)
    let             reduce using rule 1 (program -> program command .)
    list            reduce using rule 1 (program -> program command .)
    ID              reduce using rule 1 (program -> program command .)
    $end            reduce using rule 1 (program -> program command .)


state 36

    (13) command -> foreach ID . in ID
    (14) command -> foreach ID . COMMA ID in ID

    in              shift and go to state 68
    COMMA           shift and go to state 69


state 37

    (55) optend -> SEMI .

    import          reduce using rule 55 (optend -> SEMI .)
    outcsv          reduce using rule 55 (optend -> SEMI .)
    save            reduce using rule 55 (optend -> SEMI .)
    print           reduce using rule 55 (optend -> SEMI .)
    search          reduce using rule 55 (optend -> SEMI .)
    foreach         reduce using rule 55 (optend -> SEMI .)
    end             reduce using rule 55 (optend -> SEMI .)
    return          reduce using rule 55 (optend -> SEMI .)
    continue        reduce using rule 55 (optend -> SEMI .)
    if              reduce using rule 55 (optend -> SEMI .)
    else            reduce using rule 55 (optend -> SEMI .)
    def             reduce using rule 55 (optend -> SEMI .)
    connect         reduce using rule 55 (optend -> SEMI .)
    let             reduce using rule 55 (optend -> SEMI .)
    list            reduce using rule 55 (optend -> SEMI .)
    ID              reduce using rule 55 (optend -> SEMI .)
    $end            reduce using rule 55 (optend -> SEMI .)


state 38

    (10) command -> print optend .

    import          reduce using rule 10 (command -> print optend .)
    outcsv          reduce using rule 10 (command -> print optend .)
    save            reduce using rule 10 (command -> print optend .)
    print           reduce using rule 10 (command -> print optend .)
    search          reduce using rule 10 (command -> print optend .)
    foreach         reduce using rule 10 (command -> print optend .)
    end             reduce using rule 10 (command -> print optend .)
    return          reduce using rule 10 (command -> print optend .)
    continue        reduce using rule 10 (command -> print optend .)
    if              reduce using rule 10 (command -> print optend .)
    else            reduce using rule 10 (command -> print optend .)
    def             reduce using rule 10 (command -> print optend .)
    connect         reduce using rule 10 (command -> print optend .)
    let             reduce using rule 10 (command -> print optend .)
    list            reduce using rule 10 (command -> print optend .)
    ID              reduce using rule 10 (command -> print optend .)
    $end            reduce using rule 10 (command -> print optend .)


state 39

    (11) command -> print parlist .
    (52) parlist -> parlist . COMMA expression

    import          reduce using rule 11 (command -> print parlist .)
    outcsv          reduce using rule 11 (command -> print parlist .)
    save            reduce using rule 11 (command -> print parlist .)
    print           reduce using rule 11 (command -> print parlist .)
    search          reduce using rule 11 (command -> print parlist .)
    foreach         reduce using rule 11 (command -> print parlist .)
    end             reduce using rule 11 (command -> print parlist .)
    return          reduce using rule 11 (command -> print parlist .)
    continue        reduce using rule 11 (command -> print parlist .)
    if              reduce using rule 11 (command -> print parlist .)
    else            reduce using rule 11 (command -> print parlist .)
    def             reduce using rule 11 (command -> print parlist .)
    connect         reduce using rule 11 (command -> print parlist .)
    let             reduce using rule 11 (command -> print parlist .)
    list            reduce using rule 11 (command -> print parlist .)
    ID              reduce using rule 11 (command -> print parlist .)
    $end            reduce using rule 11 (command -> print parlist .)
    COMMA           shift and go to state 70


state 40

    (54) optend -> COMMA .

    import          reduce using rule 54 (optend -> COMMA .)
    outcsv          reduce using rule 54 (optend -> COMMA .)
    save            reduce using rule 54 (optend -> COMMA .)
    print           reduce using rule 54 (optend -> COMMA .)
    search          reduce using rule 54 (optend -> COMMA .)
    foreach         reduce using rule 54 (optend -> COMMA .)
    end             reduce using rule 54 (optend -> COMMA .)
    return          reduce using rule 54 (optend -> COMMA .)
    continue        reduce using rule 54 (optend -> COMMA .)
    if              reduce using rule 54 (optend -> COMMA .)
    else            reduce using rule 54 (optend -> COMMA .)
    def             reduce using rule 54 (optend -> COMMA .)
    connect         reduce using rule 54 (optend -> COMMA .)
    let             reduce using rule 54 (optend -> COMMA .)
    list            reduce using rule 54 (optend -> COMMA .)
    ID              reduce using rule 54 (optend -> COMMA .)
    $end            reduce using rule 54 (optend -> COMMA .)


state 41

    (53) parlist -> expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    COMMA           reduce using rule 53 (parlist -> expression .)
    import          reduce using rule 53 (parlist -> expression .)
    outcsv          reduce using rule 53 (parlist -> expression .)
    save            reduce using rule 53 (parlist -> expression .)
    print           reduce using rule 53 (parlist -> expression .)
    search          reduce using rule 53 (parlist -> expression .)
    foreach         reduce using rule 53 (parlist -> expression .)
    end             reduce using rule 53 (parlist -> expression .)
    return          reduce using rule 53 (parlist -> expression .)
    continue        reduce using rule 53 (parlist -> expression .)
    if              reduce using rule 53 (parlist -> expression .)
    else            reduce using rule 53 (parlist -> expression .)
    def             reduce using rule 53 (parlist -> expression .)
    connect         reduce using rule 53 (parlist -> expression .)
    let             reduce using rule 53 (parlist -> expression .)
    list            reduce using rule 53 (parlist -> expression .)
    ID              reduce using rule 53 (parlist -> expression .)
    $end            reduce using rule 53 (parlist -> expression .)
    RPAREN          reduce using rule 53 (parlist -> expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 42

    (6) command -> import STRING .

    import          reduce using rule 6 (command -> import STRING .)
    outcsv          reduce using rule 6 (command -> import STRING .)
    save            reduce using rule 6 (command -> import STRING .)
    print           reduce using rule 6 (command -> import STRING .)
    search          reduce using rule 6 (command -> import STRING .)
    foreach         reduce using rule 6 (command -> import STRING .)
    end             reduce using rule 6 (command -> import STRING .)
    return          reduce using rule 6 (command -> import STRING .)
    continue        reduce using rule 6 (command -> import STRING .)
    if              reduce using rule 6 (command -> import STRING .)
    else            reduce using rule 6 (command -> import STRING .)
    def             reduce using rule 6 (command -> import STRING .)
    connect         reduce using rule 6 (command -> import STRING .)
    let             reduce using rule 6 (command -> import STRING .)
    list            reduce using rule 6 (command -> import STRING .)
    ID              reduce using rule 6 (command -> import STRING .)
    $end            reduce using rule 6 (command -> import STRING .)


state 43

    (9) command -> save LPAREN . parlist RPAREN in ID
    (52) parlist -> . parlist COMMA expression
    (53) parlist -> . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 41
    parlist                        shift and go to state 71

state 44

    (8) command -> save ID . in ID

    in              shift and go to state 72


state 45

    (17) command -> return expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    import          reduce using rule 17 (command -> return expression .)
    outcsv          reduce using rule 17 (command -> return expression .)
    save            reduce using rule 17 (command -> return expression .)
    print           reduce using rule 17 (command -> return expression .)
    search          reduce using rule 17 (command -> return expression .)
    foreach         reduce using rule 17 (command -> return expression .)
    end             reduce using rule 17 (command -> return expression .)
    return          reduce using rule 17 (command -> return expression .)
    continue        reduce using rule 17 (command -> return expression .)
    if              reduce using rule 17 (command -> return expression .)
    else            reduce using rule 17 (command -> return expression .)
    def             reduce using rule 17 (command -> return expression .)
    connect         reduce using rule 17 (command -> return expression .)
    let             reduce using rule 17 (command -> return expression .)
    list            reduce using rule 17 (command -> return expression .)
    ID              reduce using rule 17 (command -> return expression .)
    $end            reduce using rule 17 (command -> return expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 46

    (26) command -> let error .

    import          reduce using rule 26 (command -> let error .)
    outcsv          reduce using rule 26 (command -> let error .)
    save            reduce using rule 26 (command -> let error .)
    print           reduce using rule 26 (command -> let error .)
    search          reduce using rule 26 (command -> let error .)
    foreach         reduce using rule 26 (command -> let error .)
    end             reduce using rule 26 (command -> let error .)
    return          reduce using rule 26 (command -> let error .)
    continue        reduce using rule 26 (command -> let error .)
    if              reduce using rule 26 (command -> let error .)
    else            reduce using rule 26 (command -> let error .)
    def             reduce using rule 26 (command -> let error .)
    connect         reduce using rule 26 (command -> let error .)
    let             reduce using rule 26 (command -> let error .)
    list            reduce using rule 26 (command -> let error .)
    ID              reduce using rule 26 (command -> let error .)
    $end            reduce using rule 26 (command -> let error .)


state 47

    (24) command -> let ID . EQUALS expression
    (25) command -> let ID . EQUALS command

    EQUALS          shift and go to state 73


state 48

    (49) function -> ID LPAREN . parlist RPAREN
    (52) parlist -> . parlist COMMA expression
    (53) parlist -> . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 41
    parlist                        shift and go to state 74

state 49

    (12) command -> search ID . with ID as sql

    with            shift and go to state 75


state 50

    (27) command -> list ID . EQUALS LPAREN parlist RPAREN

    EQUALS          shift and go to state 76


state 51

    (21) command -> def ID . LPAREN RPAREN
    (22) command -> def ID . LPAREN parlist RPAREN

    LPAREN          shift and go to state 77


state 52

    (23) command -> connect ID EQUALS . DBPROVIDER LPAREN STRING RPAREN

    DBPROVIDER      shift and go to state 78


state 53

    (36) expression -> MINUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 36 (expression -> MINUS expression .)
    MINUS           reduce using rule 36 (expression -> MINUS expression .)
    MULTIPLY        reduce using rule 36 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 36 (expression -> MINUS expression .)
    POWER           reduce using rule 36 (expression -> MINUS expression .)
    then            reduce using rule 36 (expression -> MINUS expression .)
    RPAREN          reduce using rule 36 (expression -> MINUS expression .)
    COMMA           reduce using rule 36 (expression -> MINUS expression .)
    LT              reduce using rule 36 (expression -> MINUS expression .)
    LE              reduce using rule 36 (expression -> MINUS expression .)
    GT              reduce using rule 36 (expression -> MINUS expression .)
    GE              reduce using rule 36 (expression -> MINUS expression .)
    EQUALS          reduce using rule 36 (expression -> MINUS expression .)
    NE              reduce using rule 36 (expression -> MINUS expression .)
    import          reduce using rule 36 (expression -> MINUS expression .)
    outcsv          reduce using rule 36 (expression -> MINUS expression .)
    save            reduce using rule 36 (expression -> MINUS expression .)
    print           reduce using rule 36 (expression -> MINUS expression .)
    search          reduce using rule 36 (expression -> MINUS expression .)
    foreach         reduce using rule 36 (expression -> MINUS expression .)
    end             reduce using rule 36 (expression -> MINUS expression .)
    return          reduce using rule 36 (expression -> MINUS expression .)
    continue        reduce using rule 36 (expression -> MINUS expression .)
    if              reduce using rule 36 (expression -> MINUS expression .)
    else            reduce using rule 36 (expression -> MINUS expression .)
    def             reduce using rule 36 (expression -> MINUS expression .)
    connect         reduce using rule 36 (expression -> MINUS expression .)
    let             reduce using rule 36 (expression -> MINUS expression .)
    list            reduce using rule 36 (expression -> MINUS expression .)
    ID              reduce using rule 36 (expression -> MINUS expression .)
    $end            reduce using rule 36 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]
  ! MULTIPLY        [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! POWER           [ shift and go to state 59 ]


state 54

    (19) command -> if relexpression then .

    import          reduce using rule 19 (command -> if relexpression then .)
    outcsv          reduce using rule 19 (command -> if relexpression then .)
    save            reduce using rule 19 (command -> if relexpression then .)
    print           reduce using rule 19 (command -> if relexpression then .)
    search          reduce using rule 19 (command -> if relexpression then .)
    foreach         reduce using rule 19 (command -> if relexpression then .)
    end             reduce using rule 19 (command -> if relexpression then .)
    return          reduce using rule 19 (command -> if relexpression then .)
    continue        reduce using rule 19 (command -> if relexpression then .)
    if              reduce using rule 19 (command -> if relexpression then .)
    else            reduce using rule 19 (command -> if relexpression then .)
    def             reduce using rule 19 (command -> if relexpression then .)
    connect         reduce using rule 19 (command -> if relexpression then .)
    let             reduce using rule 19 (command -> if relexpression then .)
    list            reduce using rule 19 (command -> if relexpression then .)
    ID              reduce using rule 19 (command -> if relexpression then .)
    $end            reduce using rule 19 (command -> if relexpression then .)


state 55

    (37) expression -> LPAREN expression . RPAREN
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    RPAREN          shift and go to state 79
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 56

    (44) relexpression -> expression LE . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 80

state 57

    (46) relexpression -> expression GE . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 81

state 58

    (41) expression -> expression DIVIDE . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 82

state 59

    (42) expression -> expression POWER . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 83

state 60

    (47) relexpression -> expression EQUALS . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 84

state 61

    (48) relexpression -> expression NE . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 85

state 62

    (43) relexpression -> expression LT . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 86

state 63

    (45) relexpression -> expression GT . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 87

state 64

    (38) expression -> expression PLUS . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 88

state 65

    (40) expression -> expression MULTIPLY . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 89

state 66

    (39) expression -> expression MINUS . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 90

state 67

    (7) command -> outcsv ID in . STRING

    STRING          shift and go to state 91


state 68

    (13) command -> foreach ID in . ID

    ID              shift and go to state 92


state 69

    (14) command -> foreach ID COMMA . ID in ID

    ID              shift and go to state 93


state 70

    (52) parlist -> parlist COMMA . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 94

state 71

    (9) command -> save LPAREN parlist . RPAREN in ID
    (52) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 95
    COMMA           shift and go to state 70


state 72

    (8) command -> save ID in . ID

    ID              shift and go to state 96


state 73

    (24) command -> let ID EQUALS . expression
    (25) command -> let ID EQUALS . command
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . print optend
    (11) command -> . print parlist
    (12) command -> . search ID with ID as sql
    (13) command -> . foreach ID in ID
    (14) command -> . foreach ID COMMA ID in ID
    (15) command -> . end
    (16) command -> . return
    (17) command -> . return expression
    (18) command -> . continue
    (19) command -> . if relexpression then
    (20) command -> . else
    (21) command -> . def ID LPAREN RPAREN
    (22) command -> . def ID LPAREN parlist RPAREN
    (23) command -> . connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN
    (24) command -> . let ID EQUALS expression
    (25) command -> . let ID EQUALS command
    (26) command -> . let error
    (27) command -> . list ID EQUALS LPAREN parlist RPAREN
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    import          shift and go to state 7
    outcsv          shift and go to state 3
    save            shift and go to state 8
    print           shift and go to state 6
    search          shift and go to state 15
    foreach         shift and go to state 5
    end             shift and go to state 13
    return          shift and go to state 10
    continue        shift and go to state 17
    if              shift and go to state 2
    else            shift and go to state 11
    def             shift and go to state 20
    connect         shift and go to state 1
    let             shift and go to state 12
    list            shift and go to state 16
    ID              shift and go to state 30
    DBID            shift and go to state 24

    function                       shift and go to state 26
    expression                     shift and go to state 98
    command                        shift and go to state 97
    variable                       shift and go to state 29

state 74

    (49) function -> ID LPAREN parlist . RPAREN
    (52) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 99
    COMMA           shift and go to state 70


state 75

    (12) command -> search ID with . ID as sql

    ID              shift and go to state 100


state 76

    (27) command -> list ID EQUALS . LPAREN parlist RPAREN

    LPAREN          shift and go to state 101


state 77

    (21) command -> def ID LPAREN . RPAREN
    (22) command -> def ID LPAREN . parlist RPAREN
    (52) parlist -> . parlist COMMA expression
    (53) parlist -> . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    RPAREN          shift and go to state 102
    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 41
    parlist                        shift and go to state 103

state 78

    (23) command -> connect ID EQUALS DBPROVIDER . LPAREN STRING RPAREN

    LPAREN          shift and go to state 104


state 79

    (37) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    POWER           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    then            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    import          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    outcsv          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    save            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    print           reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    search          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    foreach         reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    end             reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    return          reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    continue        reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    if              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    else            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    def             reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    connect         reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    let             reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    list            reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 37 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 37 (expression -> LPAREN expression RPAREN .)


state 80

    (44) relexpression -> expression LE expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 44 (relexpression -> expression LE expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 81

    (46) relexpression -> expression GE expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 46 (relexpression -> expression GE expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 82

    (41) expression -> expression DIVIDE expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 41 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 41 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 41 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 41 (expression -> expression DIVIDE expression .)
    then            reduce using rule 41 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 41 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 41 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 41 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 41 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 41 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 41 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 41 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 41 (expression -> expression DIVIDE expression .)
    import          reduce using rule 41 (expression -> expression DIVIDE expression .)
    outcsv          reduce using rule 41 (expression -> expression DIVIDE expression .)
    save            reduce using rule 41 (expression -> expression DIVIDE expression .)
    print           reduce using rule 41 (expression -> expression DIVIDE expression .)
    search          reduce using rule 41 (expression -> expression DIVIDE expression .)
    foreach         reduce using rule 41 (expression -> expression DIVIDE expression .)
    end             reduce using rule 41 (expression -> expression DIVIDE expression .)
    return          reduce using rule 41 (expression -> expression DIVIDE expression .)
    continue        reduce using rule 41 (expression -> expression DIVIDE expression .)
    if              reduce using rule 41 (expression -> expression DIVIDE expression .)
    else            reduce using rule 41 (expression -> expression DIVIDE expression .)
    def             reduce using rule 41 (expression -> expression DIVIDE expression .)
    connect         reduce using rule 41 (expression -> expression DIVIDE expression .)
    let             reduce using rule 41 (expression -> expression DIVIDE expression .)
    list            reduce using rule 41 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 41 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 41 (expression -> expression DIVIDE expression .)
    POWER           shift and go to state 59

  ! POWER           [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]
  ! MULTIPLY        [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 58 ]


state 83

    (42) expression -> expression POWER expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 42 (expression -> expression POWER expression .)
    MINUS           reduce using rule 42 (expression -> expression POWER expression .)
    MULTIPLY        reduce using rule 42 (expression -> expression POWER expression .)
    DIVIDE          reduce using rule 42 (expression -> expression POWER expression .)
    POWER           reduce using rule 42 (expression -> expression POWER expression .)
    then            reduce using rule 42 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 42 (expression -> expression POWER expression .)
    COMMA           reduce using rule 42 (expression -> expression POWER expression .)
    LT              reduce using rule 42 (expression -> expression POWER expression .)
    LE              reduce using rule 42 (expression -> expression POWER expression .)
    GT              reduce using rule 42 (expression -> expression POWER expression .)
    GE              reduce using rule 42 (expression -> expression POWER expression .)
    EQUALS          reduce using rule 42 (expression -> expression POWER expression .)
    NE              reduce using rule 42 (expression -> expression POWER expression .)
    import          reduce using rule 42 (expression -> expression POWER expression .)
    outcsv          reduce using rule 42 (expression -> expression POWER expression .)
    save            reduce using rule 42 (expression -> expression POWER expression .)
    print           reduce using rule 42 (expression -> expression POWER expression .)
    search          reduce using rule 42 (expression -> expression POWER expression .)
    foreach         reduce using rule 42 (expression -> expression POWER expression .)
    end             reduce using rule 42 (expression -> expression POWER expression .)
    return          reduce using rule 42 (expression -> expression POWER expression .)
    continue        reduce using rule 42 (expression -> expression POWER expression .)
    if              reduce using rule 42 (expression -> expression POWER expression .)
    else            reduce using rule 42 (expression -> expression POWER expression .)
    def             reduce using rule 42 (expression -> expression POWER expression .)
    connect         reduce using rule 42 (expression -> expression POWER expression .)
    let             reduce using rule 42 (expression -> expression POWER expression .)
    list            reduce using rule 42 (expression -> expression POWER expression .)
    ID              reduce using rule 42 (expression -> expression POWER expression .)
    $end            reduce using rule 42 (expression -> expression POWER expression .)

  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]
  ! MULTIPLY        [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 58 ]
  ! POWER           [ shift and go to state 59 ]


state 84

    (47) relexpression -> expression EQUALS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 47 (relexpression -> expression EQUALS expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 85

    (48) relexpression -> expression NE expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 48 (relexpression -> expression NE expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 86

    (43) relexpression -> expression LT expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 43 (relexpression -> expression LT expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 87

    (45) relexpression -> expression GT expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    then            reduce using rule 45 (relexpression -> expression GT expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 88

    (38) expression -> expression PLUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 38 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 38 (expression -> expression PLUS expression .)
    then            reduce using rule 38 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 38 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 38 (expression -> expression PLUS expression .)
    LT              reduce using rule 38 (expression -> expression PLUS expression .)
    LE              reduce using rule 38 (expression -> expression PLUS expression .)
    GT              reduce using rule 38 (expression -> expression PLUS expression .)
    GE              reduce using rule 38 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 38 (expression -> expression PLUS expression .)
    NE              reduce using rule 38 (expression -> expression PLUS expression .)
    import          reduce using rule 38 (expression -> expression PLUS expression .)
    outcsv          reduce using rule 38 (expression -> expression PLUS expression .)
    save            reduce using rule 38 (expression -> expression PLUS expression .)
    print           reduce using rule 38 (expression -> expression PLUS expression .)
    search          reduce using rule 38 (expression -> expression PLUS expression .)
    foreach         reduce using rule 38 (expression -> expression PLUS expression .)
    end             reduce using rule 38 (expression -> expression PLUS expression .)
    return          reduce using rule 38 (expression -> expression PLUS expression .)
    continue        reduce using rule 38 (expression -> expression PLUS expression .)
    if              reduce using rule 38 (expression -> expression PLUS expression .)
    else            reduce using rule 38 (expression -> expression PLUS expression .)
    def             reduce using rule 38 (expression -> expression PLUS expression .)
    connect         reduce using rule 38 (expression -> expression PLUS expression .)
    let             reduce using rule 38 (expression -> expression PLUS expression .)
    list            reduce using rule 38 (expression -> expression PLUS expression .)
    ID              reduce using rule 38 (expression -> expression PLUS expression .)
    $end            reduce using rule 38 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59

  ! MULTIPLY        [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]


state 89

    (40) expression -> expression MULTIPLY expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 40 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 40 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    then            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    COMMA           reduce using rule 40 (expression -> expression MULTIPLY expression .)
    LT              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    LE              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    GT              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    GE              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    EQUALS          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    NE              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    import          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    outcsv          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    save            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    print           reduce using rule 40 (expression -> expression MULTIPLY expression .)
    search          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    foreach         reduce using rule 40 (expression -> expression MULTIPLY expression .)
    end             reduce using rule 40 (expression -> expression MULTIPLY expression .)
    return          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    continue        reduce using rule 40 (expression -> expression MULTIPLY expression .)
    if              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    else            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    def             reduce using rule 40 (expression -> expression MULTIPLY expression .)
    connect         reduce using rule 40 (expression -> expression MULTIPLY expression .)
    let             reduce using rule 40 (expression -> expression MULTIPLY expression .)
    list            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    ID              reduce using rule 40 (expression -> expression MULTIPLY expression .)
    $end            reduce using rule 40 (expression -> expression MULTIPLY expression .)
    POWER           shift and go to state 59

  ! POWER           [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]
  ! MULTIPLY        [ shift and go to state 65 ]
  ! DIVIDE          [ shift and go to state 58 ]


state 90

    (39) expression -> expression MINUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    PLUS            reduce using rule 39 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 39 (expression -> expression MINUS expression .)
    then            reduce using rule 39 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 39 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 39 (expression -> expression MINUS expression .)
    LT              reduce using rule 39 (expression -> expression MINUS expression .)
    LE              reduce using rule 39 (expression -> expression MINUS expression .)
    GT              reduce using rule 39 (expression -> expression MINUS expression .)
    GE              reduce using rule 39 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 39 (expression -> expression MINUS expression .)
    NE              reduce using rule 39 (expression -> expression MINUS expression .)
    import          reduce using rule 39 (expression -> expression MINUS expression .)
    outcsv          reduce using rule 39 (expression -> expression MINUS expression .)
    save            reduce using rule 39 (expression -> expression MINUS expression .)
    print           reduce using rule 39 (expression -> expression MINUS expression .)
    search          reduce using rule 39 (expression -> expression MINUS expression .)
    foreach         reduce using rule 39 (expression -> expression MINUS expression .)
    end             reduce using rule 39 (expression -> expression MINUS expression .)
    return          reduce using rule 39 (expression -> expression MINUS expression .)
    continue        reduce using rule 39 (expression -> expression MINUS expression .)
    if              reduce using rule 39 (expression -> expression MINUS expression .)
    else            reduce using rule 39 (expression -> expression MINUS expression .)
    def             reduce using rule 39 (expression -> expression MINUS expression .)
    connect         reduce using rule 39 (expression -> expression MINUS expression .)
    let             reduce using rule 39 (expression -> expression MINUS expression .)
    list            reduce using rule 39 (expression -> expression MINUS expression .)
    ID              reduce using rule 39 (expression -> expression MINUS expression .)
    $end            reduce using rule 39 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59

  ! MULTIPLY        [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 66 ]


state 91

    (7) command -> outcsv ID in STRING .

    import          reduce using rule 7 (command -> outcsv ID in STRING .)
    outcsv          reduce using rule 7 (command -> outcsv ID in STRING .)
    save            reduce using rule 7 (command -> outcsv ID in STRING .)
    print           reduce using rule 7 (command -> outcsv ID in STRING .)
    search          reduce using rule 7 (command -> outcsv ID in STRING .)
    foreach         reduce using rule 7 (command -> outcsv ID in STRING .)
    end             reduce using rule 7 (command -> outcsv ID in STRING .)
    return          reduce using rule 7 (command -> outcsv ID in STRING .)
    continue        reduce using rule 7 (command -> outcsv ID in STRING .)
    if              reduce using rule 7 (command -> outcsv ID in STRING .)
    else            reduce using rule 7 (command -> outcsv ID in STRING .)
    def             reduce using rule 7 (command -> outcsv ID in STRING .)
    connect         reduce using rule 7 (command -> outcsv ID in STRING .)
    let             reduce using rule 7 (command -> outcsv ID in STRING .)
    list            reduce using rule 7 (command -> outcsv ID in STRING .)
    ID              reduce using rule 7 (command -> outcsv ID in STRING .)
    $end            reduce using rule 7 (command -> outcsv ID in STRING .)


state 92

    (13) command -> foreach ID in ID .

    import          reduce using rule 13 (command -> foreach ID in ID .)
    outcsv          reduce using rule 13 (command -> foreach ID in ID .)
    save            reduce using rule 13 (command -> foreach ID in ID .)
    print           reduce using rule 13 (command -> foreach ID in ID .)
    search          reduce using rule 13 (command -> foreach ID in ID .)
    foreach         reduce using rule 13 (command -> foreach ID in ID .)
    end             reduce using rule 13 (command -> foreach ID in ID .)
    return          reduce using rule 13 (command -> foreach ID in ID .)
    continue        reduce using rule 13 (command -> foreach ID in ID .)
    if              reduce using rule 13 (command -> foreach ID in ID .)
    else            reduce using rule 13 (command -> foreach ID in ID .)
    def             reduce using rule 13 (command -> foreach ID in ID .)
    connect         reduce using rule 13 (command -> foreach ID in ID .)
    let             reduce using rule 13 (command -> foreach ID in ID .)
    list            reduce using rule 13 (command -> foreach ID in ID .)
    ID              reduce using rule 13 (command -> foreach ID in ID .)
    $end            reduce using rule 13 (command -> foreach ID in ID .)


state 93

    (14) command -> foreach ID COMMA ID . in ID

    in              shift and go to state 105


state 94

    (52) parlist -> parlist COMMA expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    COMMA           reduce using rule 52 (parlist -> parlist COMMA expression .)
    import          reduce using rule 52 (parlist -> parlist COMMA expression .)
    outcsv          reduce using rule 52 (parlist -> parlist COMMA expression .)
    save            reduce using rule 52 (parlist -> parlist COMMA expression .)
    print           reduce using rule 52 (parlist -> parlist COMMA expression .)
    search          reduce using rule 52 (parlist -> parlist COMMA expression .)
    foreach         reduce using rule 52 (parlist -> parlist COMMA expression .)
    end             reduce using rule 52 (parlist -> parlist COMMA expression .)
    return          reduce using rule 52 (parlist -> parlist COMMA expression .)
    continue        reduce using rule 52 (parlist -> parlist COMMA expression .)
    if              reduce using rule 52 (parlist -> parlist COMMA expression .)
    else            reduce using rule 52 (parlist -> parlist COMMA expression .)
    def             reduce using rule 52 (parlist -> parlist COMMA expression .)
    connect         reduce using rule 52 (parlist -> parlist COMMA expression .)
    let             reduce using rule 52 (parlist -> parlist COMMA expression .)
    list            reduce using rule 52 (parlist -> parlist COMMA expression .)
    ID              reduce using rule 52 (parlist -> parlist COMMA expression .)
    $end            reduce using rule 52 (parlist -> parlist COMMA expression .)
    RPAREN          reduce using rule 52 (parlist -> parlist COMMA expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 95

    (9) command -> save LPAREN parlist RPAREN . in ID

    in              shift and go to state 106


state 96

    (8) command -> save ID in ID .

    import          reduce using rule 8 (command -> save ID in ID .)
    outcsv          reduce using rule 8 (command -> save ID in ID .)
    save            reduce using rule 8 (command -> save ID in ID .)
    print           reduce using rule 8 (command -> save ID in ID .)
    search          reduce using rule 8 (command -> save ID in ID .)
    foreach         reduce using rule 8 (command -> save ID in ID .)
    end             reduce using rule 8 (command -> save ID in ID .)
    return          reduce using rule 8 (command -> save ID in ID .)
    continue        reduce using rule 8 (command -> save ID in ID .)
    if              reduce using rule 8 (command -> save ID in ID .)
    else            reduce using rule 8 (command -> save ID in ID .)
    def             reduce using rule 8 (command -> save ID in ID .)
    connect         reduce using rule 8 (command -> save ID in ID .)
    let             reduce using rule 8 (command -> save ID in ID .)
    list            reduce using rule 8 (command -> save ID in ID .)
    ID              reduce using rule 8 (command -> save ID in ID .)
    $end            reduce using rule 8 (command -> save ID in ID .)


state 97

    (25) command -> let ID EQUALS command .

    import          reduce using rule 25 (command -> let ID EQUALS command .)
    outcsv          reduce using rule 25 (command -> let ID EQUALS command .)
    save            reduce using rule 25 (command -> let ID EQUALS command .)
    print           reduce using rule 25 (command -> let ID EQUALS command .)
    search          reduce using rule 25 (command -> let ID EQUALS command .)
    foreach         reduce using rule 25 (command -> let ID EQUALS command .)
    end             reduce using rule 25 (command -> let ID EQUALS command .)
    return          reduce using rule 25 (command -> let ID EQUALS command .)
    continue        reduce using rule 25 (command -> let ID EQUALS command .)
    if              reduce using rule 25 (command -> let ID EQUALS command .)
    else            reduce using rule 25 (command -> let ID EQUALS command .)
    def             reduce using rule 25 (command -> let ID EQUALS command .)
    connect         reduce using rule 25 (command -> let ID EQUALS command .)
    let             reduce using rule 25 (command -> let ID EQUALS command .)
    list            reduce using rule 25 (command -> let ID EQUALS command .)
    ID              reduce using rule 25 (command -> let ID EQUALS command .)
    $end            reduce using rule 25 (command -> let ID EQUALS command .)


state 98

    (24) command -> let ID EQUALS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . POWER expression

    import          reduce using rule 24 (command -> let ID EQUALS expression .)
    outcsv          reduce using rule 24 (command -> let ID EQUALS expression .)
    save            reduce using rule 24 (command -> let ID EQUALS expression .)
    print           reduce using rule 24 (command -> let ID EQUALS expression .)
    search          reduce using rule 24 (command -> let ID EQUALS expression .)
    foreach         reduce using rule 24 (command -> let ID EQUALS expression .)
    end             reduce using rule 24 (command -> let ID EQUALS expression .)
    return          reduce using rule 24 (command -> let ID EQUALS expression .)
    continue        reduce using rule 24 (command -> let ID EQUALS expression .)
    if              reduce using rule 24 (command -> let ID EQUALS expression .)
    else            reduce using rule 24 (command -> let ID EQUALS expression .)
    def             reduce using rule 24 (command -> let ID EQUALS expression .)
    connect         reduce using rule 24 (command -> let ID EQUALS expression .)
    let             reduce using rule 24 (command -> let ID EQUALS expression .)
    list            reduce using rule 24 (command -> let ID EQUALS expression .)
    ID              reduce using rule 24 (command -> let ID EQUALS expression .)
    $end            reduce using rule 24 (command -> let ID EQUALS expression .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    MULTIPLY        shift and go to state 65
    DIVIDE          shift and go to state 58
    POWER           shift and go to state 59


state 99

    (49) function -> ID LPAREN parlist RPAREN .

    import          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    save            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    print           reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    search          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    end             reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    return          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    continue        reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    if              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    else            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    def             reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    connect         reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    let             reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    list            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    ID              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    $end            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    PLUS            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    MINUS           reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    MULTIPLY        reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    DIVIDE          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    POWER           reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    then            reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    COMMA           reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    LT              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    LE              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    GT              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    GE              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    EQUALS          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    NE              reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)
    RPAREN          reduce using rule 49 (function -> ID LPAREN parlist RPAREN .)


state 100

    (12) command -> search ID with ID . as sql

    as              shift and go to state 107


state 101

    (27) command -> list ID EQUALS LPAREN . parlist RPAREN
    (52) parlist -> . parlist COMMA expression
    (53) parlist -> . expression
    (31) expression -> . variable
    (32) expression -> . function
    (33) expression -> . INTEGER
    (34) expression -> . FLOAT
    (35) expression -> . STRING
    (36) expression -> . MINUS expression
    (37) expression -> . LPAREN expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression POWER expression
    (50) variable -> . ID
    (51) variable -> . DBID
    (49) function -> . ID LPAREN parlist RPAREN

    INTEGER         shift and go to state 25
    FLOAT           shift and go to state 31
    STRING          shift and go to state 23
    MINUS           shift and go to state 22
    LPAREN          shift and go to state 28
    ID              shift and go to state 30
    DBID            shift and go to state 24

    variable                       shift and go to state 29
    function                       shift and go to state 26
    expression                     shift and go to state 41
    parlist                        shift and go to state 108

state 102

    (21) command -> def ID LPAREN RPAREN .

    import          reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    outcsv          reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    save            reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    print           reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    search          reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    foreach         reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    end             reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    return          reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    continue        reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    if              reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    else            reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    def             reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    connect         reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    let             reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    list            reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    ID              reduce using rule 21 (command -> def ID LPAREN RPAREN .)
    $end            reduce using rule 21 (command -> def ID LPAREN RPAREN .)


state 103

    (22) command -> def ID LPAREN parlist . RPAREN
    (52) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 109
    COMMA           shift and go to state 70


state 104

    (23) command -> connect ID EQUALS DBPROVIDER LPAREN . STRING RPAREN

    STRING          shift and go to state 110


state 105

    (14) command -> foreach ID COMMA ID in . ID

    ID              shift and go to state 111


state 106

    (9) command -> save LPAREN parlist RPAREN in . ID

    ID              shift and go to state 112


state 107

    (12) command -> search ID with ID as . sql
    (28) sql -> . SELECT
    (29) sql -> . INSERT
    (30) sql -> . UPDATE

    SELECT          shift and go to state 116
    INSERT          shift and go to state 113
    UPDATE          shift and go to state 114

    sql                            shift and go to state 115

state 108

    (27) command -> list ID EQUALS LPAREN parlist . RPAREN
    (52) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 117
    COMMA           shift and go to state 70


state 109

    (22) command -> def ID LPAREN parlist RPAREN .

    import          reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    save            reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    print           reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    search          reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    end             reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    return          reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    continue        reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    if              reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    else            reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    def             reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    connect         reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    let             reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    list            reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    ID              reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)
    $end            reduce using rule 22 (command -> def ID LPAREN parlist RPAREN .)


state 110

    (23) command -> connect ID EQUALS DBPROVIDER LPAREN STRING . RPAREN

    RPAREN          shift and go to state 118


state 111

    (14) command -> foreach ID COMMA ID in ID .

    import          reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    outcsv          reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    save            reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    print           reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    search          reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    foreach         reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    end             reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    return          reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    continue        reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    if              reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    else            reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    def             reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    connect         reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    let             reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    list            reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    ID              reduce using rule 14 (command -> foreach ID COMMA ID in ID .)
    $end            reduce using rule 14 (command -> foreach ID COMMA ID in ID .)


state 112

    (9) command -> save LPAREN parlist RPAREN in ID .

    import          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    outcsv          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    save            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    print           reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    search          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    foreach         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    end             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    return          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    continue        reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    if              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    else            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    def             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    connect         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    let             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    list            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    ID              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    $end            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)


state 113

    (29) sql -> INSERT .

    import          reduce using rule 29 (sql -> INSERT .)
    outcsv          reduce using rule 29 (sql -> INSERT .)
    save            reduce using rule 29 (sql -> INSERT .)
    print           reduce using rule 29 (sql -> INSERT .)
    search          reduce using rule 29 (sql -> INSERT .)
    foreach         reduce using rule 29 (sql -> INSERT .)
    end             reduce using rule 29 (sql -> INSERT .)
    return          reduce using rule 29 (sql -> INSERT .)
    continue        reduce using rule 29 (sql -> INSERT .)
    if              reduce using rule 29 (sql -> INSERT .)
    else            reduce using rule 29 (sql -> INSERT .)
    def             reduce using rule 29 (sql -> INSERT .)
    connect         reduce using rule 29 (sql -> INSERT .)
    let             reduce using rule 29 (sql -> INSERT .)
    list            reduce using rule 29 (sql -> INSERT .)
    ID              reduce using rule 29 (sql -> INSERT .)
    $end            reduce using rule 29 (sql -> INSERT .)


state 114

    (30) sql -> UPDATE .

    import          reduce using rule 30 (sql -> UPDATE .)
    outcsv          reduce using rule 30 (sql -> UPDATE .)
    save            reduce using rule 30 (sql -> UPDATE .)
    print           reduce using rule 30 (sql -> UPDATE .)
    search          reduce using rule 30 (sql -> UPDATE .)
    foreach         reduce using rule 30 (sql -> UPDATE .)
    end             reduce using rule 30 (sql -> UPDATE .)
    return          reduce using rule 30 (sql -> UPDATE .)
    continue        reduce using rule 30 (sql -> UPDATE .)
    if              reduce using rule 30 (sql -> UPDATE .)
    else            reduce using rule 30 (sql -> UPDATE .)
    def             reduce using rule 30 (sql -> UPDATE .)
    connect         reduce using rule 30 (sql -> UPDATE .)
    let             reduce using rule 30 (sql -> UPDATE .)
    list            reduce using rule 30 (sql -> UPDATE .)
    ID              reduce using rule 30 (sql -> UPDATE .)
    $end            reduce using rule 30 (sql -> UPDATE .)


state 115

    (12) command -> search ID with ID as sql .

    import          reduce using rule 12 (command -> search ID with ID as sql .)
    outcsv          reduce using rule 12 (command -> search ID with ID as sql .)
    save            reduce using rule 12 (command -> search ID with ID as sql .)
    print           reduce using rule 12 (command -> search ID with ID as sql .)
    search          reduce using rule 12 (command -> search ID with ID as sql .)
    foreach         reduce using rule 12 (command -> search ID with ID as sql .)
    end             reduce using rule 12 (command -> search ID with ID as sql .)
    return          reduce using rule 12 (command -> search ID with ID as sql .)
    continue        reduce using rule 12 (command -> search ID with ID as sql .)
    if              reduce using rule 12 (command -> search ID with ID as sql .)
    else            reduce using rule 12 (command -> search ID with ID as sql .)
    def             reduce using rule 12 (command -> search ID with ID as sql .)
    connect         reduce using rule 12 (command -> search ID with ID as sql .)
    let             reduce using rule 12 (command -> search ID with ID as sql .)
    list            reduce using rule 12 (command -> search ID with ID as sql .)
    ID              reduce using rule 12 (command -> search ID with ID as sql .)
    $end            reduce using rule 12 (command -> search ID with ID as sql .)


state 116

    (28) sql -> SELECT .

    import          reduce using rule 28 (sql -> SELECT .)
    outcsv          reduce using rule 28 (sql -> SELECT .)
    save            reduce using rule 28 (sql -> SELECT .)
    print           reduce using rule 28 (sql -> SELECT .)
    search          reduce using rule 28 (sql -> SELECT .)
    foreach         reduce using rule 28 (sql -> SELECT .)
    end             reduce using rule 28 (sql -> SELECT .)
    return          reduce using rule 28 (sql -> SELECT .)
    continue        reduce using rule 28 (sql -> SELECT .)
    if              reduce using rule 28 (sql -> SELECT .)
    else            reduce using rule 28 (sql -> SELECT .)
    def             reduce using rule 28 (sql -> SELECT .)
    connect         reduce using rule 28 (sql -> SELECT .)
    let             reduce using rule 28 (sql -> SELECT .)
    list            reduce using rule 28 (sql -> SELECT .)
    ID              reduce using rule 28 (sql -> SELECT .)
    $end            reduce using rule 28 (sql -> SELECT .)


state 117

    (27) command -> list ID EQUALS LPAREN parlist RPAREN .

    import          reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    outcsv          reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    save            reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    print           reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    search          reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    foreach         reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    end             reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    return          reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    continue        reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    if              reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    else            reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    def             reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    connect         reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    let             reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    list            reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    ID              reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    $end            reduce using rule 27 (command -> list ID EQUALS LPAREN parlist RPAREN .)


state 118

    (23) command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .

    import          reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    outcsv          reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    save            reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    print           reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    search          reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    foreach         reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    end             reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    return          reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    continue        reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    if              reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    else            reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    def             reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    connect         reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    let             reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    list            reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    ID              reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)
    $end            reduce using rule 23 (command -> connect ID EQUALS DBPROVIDER LPAREN STRING RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 6 resolved as shift
WARNING: shift/reduce conflict for ID in state 10 resolved as shift
