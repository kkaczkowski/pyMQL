Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program command
Rule 2     program -> command
Rule 3     program -> program function
Rule 4     program -> function
Rule 5     program -> error
Rule 6     command -> import STRING
Rule 7     command -> outcsv ID in STRING
Rule 8     command -> save ID in ID
Rule 9     command -> save LPAREN parlist RPAREN in ID
Rule 10    command -> search ID with ID as sql
Rule 11    command -> foreach ID in ID
Rule 12    command -> foreach ID COMMA ID in ID
Rule 13    command -> end
Rule 14    command -> return
Rule 15    command -> return expression
Rule 16    command -> continue
Rule 17    command -> if relexpression then
Rule 18    command -> else
Rule 19    command -> def ID LPAREN RPAREN
Rule 20    command -> def ID LPAREN parlist RPAREN
Rule 21    command -> connect ID EQUALS expression
Rule 22    command -> let ID EQUALS expression
Rule 23    command -> let error
Rule 24    command -> list ID EQUALS LPAREN parlist RPAREN
Rule 25    sql -> SELECT
Rule 26    sql -> INSERT
Rule 27    sql -> UPDATE
Rule 28    expression -> variable
Rule 29    expression -> dbvariable
Rule 30    expression -> FLOAT
Rule 31    expression -> INTEGER
Rule 32    expression -> STRING
Rule 33    expression -> function
Rule 34    expression -> slice
Rule 35    expression -> MINUS expression
Rule 36    expression -> LPAREN expression RPAREN
Rule 37    expression -> expression PLUS expression
Rule 38    expression -> expression MINUS expression
Rule 39    expression -> expression MULTIPLY expression
Rule 40    expression -> expression DIVIDE expression
Rule 41    expression -> expression POWER expression
Rule 42    relexpression -> expression LT expression
Rule 43    relexpression -> expression LE expression
Rule 44    relexpression -> expression GT expression
Rule 45    relexpression -> expression GE expression
Rule 46    relexpression -> expression EQUALS expression
Rule 47    relexpression -> expression NE expression
Rule 48    function -> ID LPAREN parlist RPAREN
Rule 49    function -> ID LPAREN RPAREN
Rule 50    slice -> ID LQPAREN expression COLON expression RQPAREN
Rule 51    slice -> ID LQPAREN COLON expression RQPAREN
Rule 52    slice -> ID LQPAREN expression COLON RQPAREN
Rule 53    slice -> ID LQPAREN expression RQPAREN
Rule 54    variable -> ID
Rule 55    dbvariable -> DBID
Rule 56    parlist -> parlist COMMA expression
Rule 57    parlist -> expression

Terminals, with rules where they appear

COLON                : 50 51 52
COMMA                : 12 56
DBID                 : 55
DIVIDE               : 40
EQUALS               : 21 22 24 46
FLOAT                : 30
GE                   : 45
GT                   : 44
ID                   : 7 8 8 9 10 10 11 11 12 12 12 19 20 21 22 24 48 49 50 51 52 53 54
INSERT               : 26
INTEGER              : 31
LE                   : 43
LPAREN               : 9 19 20 24 36 48 49
LQPAREN              : 50 51 52 53
LT                   : 42
MINUS                : 35 38
MULTIPLY             : 39
NE                   : 47
PLUS                 : 37
POWER                : 41
RPAREN               : 9 19 20 24 36 48 49
RQPAREN              : 50 51 52 53
SELECT               : 25
STRING               : 6 7 32
UPDATE               : 27
as                   : 10
connect              : 21
continue             : 16
def                  : 19 20
else                 : 18
end                  : 13
error                : 5 23
foreach              : 11 12
if                   : 17
import               : 6
in                   : 7 8 9 11 12
let                  : 22 23
list                 : 24
outcsv               : 7
return               : 14 15
save                 : 8 9
search               : 10
then                 : 17
with                 : 10

Nonterminals, with rules where they appear

command              : 1 2
dbvariable           : 29
expression           : 15 21 22 35 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 50 50 51 52 53 56 57
function             : 3 4 33
parlist              : 9 20 24 48 56
program              : 1 3 0
relexpression        : 17
slice                : 34
sql                  : 10
variable             : 28

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program command
    (2) program -> . command
    (3) program -> . program function
    (4) program -> . function
    (5) program -> . error
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . search ID with ID as sql
    (11) command -> . foreach ID in ID
    (12) command -> . foreach ID COMMA ID in ID
    (13) command -> . end
    (14) command -> . return
    (15) command -> . return expression
    (16) command -> . continue
    (17) command -> . if relexpression then
    (18) command -> . else
    (19) command -> . def ID LPAREN RPAREN
    (20) command -> . def ID LPAREN parlist RPAREN
    (21) command -> . connect ID EQUALS expression
    (22) command -> . let ID EQUALS expression
    (23) command -> . let error
    (24) command -> . list ID EQUALS LPAREN parlist RPAREN
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN

    error           shift and go to state 18
    import          shift and go to state 6
    outcsv          shift and go to state 3
    save            shift and go to state 7
    search          shift and go to state 14
    foreach         shift and go to state 5
    end             shift and go to state 12
    return          shift and go to state 9
    continue        shift and go to state 16
    if              shift and go to state 2
    else            shift and go to state 10
    def             shift and go to state 19
    connect         shift and go to state 1
    let             shift and go to state 11
    list            shift and go to state 15
    ID              shift and go to state 13

    function                       shift and go to state 8
    program                        shift and go to state 4
    command                        shift and go to state 17

state 1

    (21) command -> connect . ID EQUALS expression

    ID              shift and go to state 20


state 2

    (17) command -> if . relexpression then
    (42) relexpression -> . expression LT expression
    (43) relexpression -> . expression LE expression
    (44) relexpression -> . expression GT expression
    (45) relexpression -> . expression GE expression
    (46) relexpression -> . expression EQUALS expression
    (47) relexpression -> . expression NE expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    relexpression                  shift and go to state 27
    variable                       shift and go to state 30
    expression                     shift and go to state 33

state 3

    (7) command -> outcsv . ID in STRING

    ID              shift and go to state 34


state 4

    (0) S' -> program .
    (1) program -> program . command
    (3) program -> program . function
    (6) command -> . import STRING
    (7) command -> . outcsv ID in STRING
    (8) command -> . save ID in ID
    (9) command -> . save LPAREN parlist RPAREN in ID
    (10) command -> . search ID with ID as sql
    (11) command -> . foreach ID in ID
    (12) command -> . foreach ID COMMA ID in ID
    (13) command -> . end
    (14) command -> . return
    (15) command -> . return expression
    (16) command -> . continue
    (17) command -> . if relexpression then
    (18) command -> . else
    (19) command -> . def ID LPAREN RPAREN
    (20) command -> . def ID LPAREN parlist RPAREN
    (21) command -> . connect ID EQUALS expression
    (22) command -> . let ID EQUALS expression
    (23) command -> . let error
    (24) command -> . list ID EQUALS LPAREN parlist RPAREN
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN

    import          shift and go to state 6
    outcsv          shift and go to state 3
    save            shift and go to state 7
    search          shift and go to state 14
    foreach         shift and go to state 5
    end             shift and go to state 12
    return          shift and go to state 9
    continue        shift and go to state 16
    if              shift and go to state 2
    else            shift and go to state 10
    def             shift and go to state 19
    connect         shift and go to state 1
    let             shift and go to state 11
    list            shift and go to state 15
    ID              shift and go to state 13

    function                       shift and go to state 35
    command                        shift and go to state 36

state 5

    (11) command -> foreach . ID in ID
    (12) command -> foreach . ID COMMA ID in ID

    ID              shift and go to state 37


state 6

    (6) command -> import . STRING

    STRING          shift and go to state 38


state 7

    (8) command -> save . ID in ID
    (9) command -> save . LPAREN parlist RPAREN in ID

    ID              shift and go to state 40
    LPAREN          shift and go to state 39


state 8

    (4) program -> function .

    import          reduce using rule 4 (program -> function .)
    outcsv          reduce using rule 4 (program -> function .)
    save            reduce using rule 4 (program -> function .)
    search          reduce using rule 4 (program -> function .)
    foreach         reduce using rule 4 (program -> function .)
    end             reduce using rule 4 (program -> function .)
    return          reduce using rule 4 (program -> function .)
    continue        reduce using rule 4 (program -> function .)
    if              reduce using rule 4 (program -> function .)
    else            reduce using rule 4 (program -> function .)
    def             reduce using rule 4 (program -> function .)
    connect         reduce using rule 4 (program -> function .)
    let             reduce using rule 4 (program -> function .)
    list            reduce using rule 4 (program -> function .)
    ID              reduce using rule 4 (program -> function .)
    $end            reduce using rule 4 (program -> function .)


state 9

    (14) command -> return .
    (15) command -> return . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

  ! shift/reduce conflict for ID resolved as shift
    import          reduce using rule 14 (command -> return .)
    outcsv          reduce using rule 14 (command -> return .)
    save            reduce using rule 14 (command -> return .)
    search          reduce using rule 14 (command -> return .)
    foreach         reduce using rule 14 (command -> return .)
    end             reduce using rule 14 (command -> return .)
    return          reduce using rule 14 (command -> return .)
    continue        reduce using rule 14 (command -> return .)
    if              reduce using rule 14 (command -> return .)
    else            reduce using rule 14 (command -> return .)
    def             reduce using rule 14 (command -> return .)
    connect         reduce using rule 14 (command -> return .)
    let             reduce using rule 14 (command -> return .)
    list            reduce using rule 14 (command -> return .)
    $end            reduce using rule 14 (command -> return .)
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

  ! ID              [ reduce using rule 14 (command -> return .) ]

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 41

state 10

    (18) command -> else .

    import          reduce using rule 18 (command -> else .)
    outcsv          reduce using rule 18 (command -> else .)
    save            reduce using rule 18 (command -> else .)
    search          reduce using rule 18 (command -> else .)
    foreach         reduce using rule 18 (command -> else .)
    end             reduce using rule 18 (command -> else .)
    return          reduce using rule 18 (command -> else .)
    continue        reduce using rule 18 (command -> else .)
    if              reduce using rule 18 (command -> else .)
    else            reduce using rule 18 (command -> else .)
    def             reduce using rule 18 (command -> else .)
    connect         reduce using rule 18 (command -> else .)
    let             reduce using rule 18 (command -> else .)
    list            reduce using rule 18 (command -> else .)
    ID              reduce using rule 18 (command -> else .)
    $end            reduce using rule 18 (command -> else .)


state 11

    (22) command -> let . ID EQUALS expression
    (23) command -> let . error

    ID              shift and go to state 43
    error           shift and go to state 42


state 12

    (13) command -> end .

    import          reduce using rule 13 (command -> end .)
    outcsv          reduce using rule 13 (command -> end .)
    save            reduce using rule 13 (command -> end .)
    search          reduce using rule 13 (command -> end .)
    foreach         reduce using rule 13 (command -> end .)
    end             reduce using rule 13 (command -> end .)
    return          reduce using rule 13 (command -> end .)
    continue        reduce using rule 13 (command -> end .)
    if              reduce using rule 13 (command -> end .)
    else            reduce using rule 13 (command -> end .)
    def             reduce using rule 13 (command -> end .)
    connect         reduce using rule 13 (command -> end .)
    let             reduce using rule 13 (command -> end .)
    list            reduce using rule 13 (command -> end .)
    ID              reduce using rule 13 (command -> end .)
    $end            reduce using rule 13 (command -> end .)


state 13

    (48) function -> ID . LPAREN parlist RPAREN
    (49) function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 44


state 14

    (10) command -> search . ID with ID as sql

    ID              shift and go to state 45


state 15

    (24) command -> list . ID EQUALS LPAREN parlist RPAREN

    ID              shift and go to state 46


state 16

    (16) command -> continue .

    import          reduce using rule 16 (command -> continue .)
    outcsv          reduce using rule 16 (command -> continue .)
    save            reduce using rule 16 (command -> continue .)
    search          reduce using rule 16 (command -> continue .)
    foreach         reduce using rule 16 (command -> continue .)
    end             reduce using rule 16 (command -> continue .)
    return          reduce using rule 16 (command -> continue .)
    continue        reduce using rule 16 (command -> continue .)
    if              reduce using rule 16 (command -> continue .)
    else            reduce using rule 16 (command -> continue .)
    def             reduce using rule 16 (command -> continue .)
    connect         reduce using rule 16 (command -> continue .)
    let             reduce using rule 16 (command -> continue .)
    list            reduce using rule 16 (command -> continue .)
    ID              reduce using rule 16 (command -> continue .)
    $end            reduce using rule 16 (command -> continue .)


state 17

    (2) program -> command .

    import          reduce using rule 2 (program -> command .)
    outcsv          reduce using rule 2 (program -> command .)
    save            reduce using rule 2 (program -> command .)
    search          reduce using rule 2 (program -> command .)
    foreach         reduce using rule 2 (program -> command .)
    end             reduce using rule 2 (program -> command .)
    return          reduce using rule 2 (program -> command .)
    continue        reduce using rule 2 (program -> command .)
    if              reduce using rule 2 (program -> command .)
    else            reduce using rule 2 (program -> command .)
    def             reduce using rule 2 (program -> command .)
    connect         reduce using rule 2 (program -> command .)
    let             reduce using rule 2 (program -> command .)
    list            reduce using rule 2 (program -> command .)
    ID              reduce using rule 2 (program -> command .)
    $end            reduce using rule 2 (program -> command .)


state 18

    (5) program -> error .

    import          reduce using rule 5 (program -> error .)
    outcsv          reduce using rule 5 (program -> error .)
    save            reduce using rule 5 (program -> error .)
    search          reduce using rule 5 (program -> error .)
    foreach         reduce using rule 5 (program -> error .)
    end             reduce using rule 5 (program -> error .)
    return          reduce using rule 5 (program -> error .)
    continue        reduce using rule 5 (program -> error .)
    if              reduce using rule 5 (program -> error .)
    else            reduce using rule 5 (program -> error .)
    def             reduce using rule 5 (program -> error .)
    connect         reduce using rule 5 (program -> error .)
    let             reduce using rule 5 (program -> error .)
    list            reduce using rule 5 (program -> error .)
    ID              reduce using rule 5 (program -> error .)
    $end            reduce using rule 5 (program -> error .)


state 19

    (19) command -> def . ID LPAREN RPAREN
    (20) command -> def . ID LPAREN parlist RPAREN

    ID              shift and go to state 47


state 20

    (21) command -> connect ID . EQUALS expression

    EQUALS          shift and go to state 48


state 21

    (35) expression -> MINUS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 49

state 22

    (29) expression -> dbvariable .

    PLUS            reduce using rule 29 (expression -> dbvariable .)
    MINUS           reduce using rule 29 (expression -> dbvariable .)
    MULTIPLY        reduce using rule 29 (expression -> dbvariable .)
    DIVIDE          reduce using rule 29 (expression -> dbvariable .)
    POWER           reduce using rule 29 (expression -> dbvariable .)
    LT              reduce using rule 29 (expression -> dbvariable .)
    LE              reduce using rule 29 (expression -> dbvariable .)
    GT              reduce using rule 29 (expression -> dbvariable .)
    GE              reduce using rule 29 (expression -> dbvariable .)
    EQUALS          reduce using rule 29 (expression -> dbvariable .)
    NE              reduce using rule 29 (expression -> dbvariable .)
    import          reduce using rule 29 (expression -> dbvariable .)
    outcsv          reduce using rule 29 (expression -> dbvariable .)
    save            reduce using rule 29 (expression -> dbvariable .)
    search          reduce using rule 29 (expression -> dbvariable .)
    foreach         reduce using rule 29 (expression -> dbvariable .)
    end             reduce using rule 29 (expression -> dbvariable .)
    return          reduce using rule 29 (expression -> dbvariable .)
    continue        reduce using rule 29 (expression -> dbvariable .)
    if              reduce using rule 29 (expression -> dbvariable .)
    else            reduce using rule 29 (expression -> dbvariable .)
    def             reduce using rule 29 (expression -> dbvariable .)
    connect         reduce using rule 29 (expression -> dbvariable .)
    let             reduce using rule 29 (expression -> dbvariable .)
    list            reduce using rule 29 (expression -> dbvariable .)
    ID              reduce using rule 29 (expression -> dbvariable .)
    $end            reduce using rule 29 (expression -> dbvariable .)
    RPAREN          reduce using rule 29 (expression -> dbvariable .)
    COMMA           reduce using rule 29 (expression -> dbvariable .)
    COLON           reduce using rule 29 (expression -> dbvariable .)
    RQPAREN         reduce using rule 29 (expression -> dbvariable .)
    then            reduce using rule 29 (expression -> dbvariable .)


state 23

    (55) dbvariable -> DBID .

    PLUS            reduce using rule 55 (dbvariable -> DBID .)
    MINUS           reduce using rule 55 (dbvariable -> DBID .)
    MULTIPLY        reduce using rule 55 (dbvariable -> DBID .)
    DIVIDE          reduce using rule 55 (dbvariable -> DBID .)
    POWER           reduce using rule 55 (dbvariable -> DBID .)
    then            reduce using rule 55 (dbvariable -> DBID .)
    LT              reduce using rule 55 (dbvariable -> DBID .)
    LE              reduce using rule 55 (dbvariable -> DBID .)
    GT              reduce using rule 55 (dbvariable -> DBID .)
    GE              reduce using rule 55 (dbvariable -> DBID .)
    EQUALS          reduce using rule 55 (dbvariable -> DBID .)
    NE              reduce using rule 55 (dbvariable -> DBID .)
    import          reduce using rule 55 (dbvariable -> DBID .)
    outcsv          reduce using rule 55 (dbvariable -> DBID .)
    save            reduce using rule 55 (dbvariable -> DBID .)
    search          reduce using rule 55 (dbvariable -> DBID .)
    foreach         reduce using rule 55 (dbvariable -> DBID .)
    end             reduce using rule 55 (dbvariable -> DBID .)
    return          reduce using rule 55 (dbvariable -> DBID .)
    continue        reduce using rule 55 (dbvariable -> DBID .)
    if              reduce using rule 55 (dbvariable -> DBID .)
    else            reduce using rule 55 (dbvariable -> DBID .)
    def             reduce using rule 55 (dbvariable -> DBID .)
    connect         reduce using rule 55 (dbvariable -> DBID .)
    let             reduce using rule 55 (dbvariable -> DBID .)
    list            reduce using rule 55 (dbvariable -> DBID .)
    ID              reduce using rule 55 (dbvariable -> DBID .)
    $end            reduce using rule 55 (dbvariable -> DBID .)
    RPAREN          reduce using rule 55 (dbvariable -> DBID .)
    COMMA           reduce using rule 55 (dbvariable -> DBID .)
    COLON           reduce using rule 55 (dbvariable -> DBID .)
    RQPAREN         reduce using rule 55 (dbvariable -> DBID .)


state 24

    (31) expression -> INTEGER .

    PLUS            reduce using rule 31 (expression -> INTEGER .)
    MINUS           reduce using rule 31 (expression -> INTEGER .)
    MULTIPLY        reduce using rule 31 (expression -> INTEGER .)
    DIVIDE          reduce using rule 31 (expression -> INTEGER .)
    POWER           reduce using rule 31 (expression -> INTEGER .)
    LT              reduce using rule 31 (expression -> INTEGER .)
    LE              reduce using rule 31 (expression -> INTEGER .)
    GT              reduce using rule 31 (expression -> INTEGER .)
    GE              reduce using rule 31 (expression -> INTEGER .)
    EQUALS          reduce using rule 31 (expression -> INTEGER .)
    NE              reduce using rule 31 (expression -> INTEGER .)
    import          reduce using rule 31 (expression -> INTEGER .)
    outcsv          reduce using rule 31 (expression -> INTEGER .)
    save            reduce using rule 31 (expression -> INTEGER .)
    search          reduce using rule 31 (expression -> INTEGER .)
    foreach         reduce using rule 31 (expression -> INTEGER .)
    end             reduce using rule 31 (expression -> INTEGER .)
    return          reduce using rule 31 (expression -> INTEGER .)
    continue        reduce using rule 31 (expression -> INTEGER .)
    if              reduce using rule 31 (expression -> INTEGER .)
    else            reduce using rule 31 (expression -> INTEGER .)
    def             reduce using rule 31 (expression -> INTEGER .)
    connect         reduce using rule 31 (expression -> INTEGER .)
    let             reduce using rule 31 (expression -> INTEGER .)
    list            reduce using rule 31 (expression -> INTEGER .)
    ID              reduce using rule 31 (expression -> INTEGER .)
    $end            reduce using rule 31 (expression -> INTEGER .)
    RPAREN          reduce using rule 31 (expression -> INTEGER .)
    COMMA           reduce using rule 31 (expression -> INTEGER .)
    COLON           reduce using rule 31 (expression -> INTEGER .)
    RQPAREN         reduce using rule 31 (expression -> INTEGER .)
    then            reduce using rule 31 (expression -> INTEGER .)


state 25

    (33) expression -> function .

    PLUS            reduce using rule 33 (expression -> function .)
    MINUS           reduce using rule 33 (expression -> function .)
    MULTIPLY        reduce using rule 33 (expression -> function .)
    DIVIDE          reduce using rule 33 (expression -> function .)
    POWER           reduce using rule 33 (expression -> function .)
    LT              reduce using rule 33 (expression -> function .)
    LE              reduce using rule 33 (expression -> function .)
    GT              reduce using rule 33 (expression -> function .)
    GE              reduce using rule 33 (expression -> function .)
    EQUALS          reduce using rule 33 (expression -> function .)
    NE              reduce using rule 33 (expression -> function .)
    import          reduce using rule 33 (expression -> function .)
    outcsv          reduce using rule 33 (expression -> function .)
    save            reduce using rule 33 (expression -> function .)
    search          reduce using rule 33 (expression -> function .)
    foreach         reduce using rule 33 (expression -> function .)
    end             reduce using rule 33 (expression -> function .)
    return          reduce using rule 33 (expression -> function .)
    continue        reduce using rule 33 (expression -> function .)
    if              reduce using rule 33 (expression -> function .)
    else            reduce using rule 33 (expression -> function .)
    def             reduce using rule 33 (expression -> function .)
    connect         reduce using rule 33 (expression -> function .)
    let             reduce using rule 33 (expression -> function .)
    list            reduce using rule 33 (expression -> function .)
    ID              reduce using rule 33 (expression -> function .)
    $end            reduce using rule 33 (expression -> function .)
    RPAREN          reduce using rule 33 (expression -> function .)
    COMMA           reduce using rule 33 (expression -> function .)
    COLON           reduce using rule 33 (expression -> function .)
    RQPAREN         reduce using rule 33 (expression -> function .)
    then            reduce using rule 33 (expression -> function .)


state 26

    (32) expression -> STRING .

    PLUS            reduce using rule 32 (expression -> STRING .)
    MINUS           reduce using rule 32 (expression -> STRING .)
    MULTIPLY        reduce using rule 32 (expression -> STRING .)
    DIVIDE          reduce using rule 32 (expression -> STRING .)
    POWER           reduce using rule 32 (expression -> STRING .)
    LT              reduce using rule 32 (expression -> STRING .)
    LE              reduce using rule 32 (expression -> STRING .)
    GT              reduce using rule 32 (expression -> STRING .)
    GE              reduce using rule 32 (expression -> STRING .)
    EQUALS          reduce using rule 32 (expression -> STRING .)
    NE              reduce using rule 32 (expression -> STRING .)
    import          reduce using rule 32 (expression -> STRING .)
    outcsv          reduce using rule 32 (expression -> STRING .)
    save            reduce using rule 32 (expression -> STRING .)
    search          reduce using rule 32 (expression -> STRING .)
    foreach         reduce using rule 32 (expression -> STRING .)
    end             reduce using rule 32 (expression -> STRING .)
    return          reduce using rule 32 (expression -> STRING .)
    continue        reduce using rule 32 (expression -> STRING .)
    if              reduce using rule 32 (expression -> STRING .)
    else            reduce using rule 32 (expression -> STRING .)
    def             reduce using rule 32 (expression -> STRING .)
    connect         reduce using rule 32 (expression -> STRING .)
    let             reduce using rule 32 (expression -> STRING .)
    list            reduce using rule 32 (expression -> STRING .)
    ID              reduce using rule 32 (expression -> STRING .)
    $end            reduce using rule 32 (expression -> STRING .)
    RPAREN          reduce using rule 32 (expression -> STRING .)
    COMMA           reduce using rule 32 (expression -> STRING .)
    COLON           reduce using rule 32 (expression -> STRING .)
    RQPAREN         reduce using rule 32 (expression -> STRING .)
    then            reduce using rule 32 (expression -> STRING .)


state 27

    (17) command -> if relexpression . then

    then            shift and go to state 50


state 28

    (34) expression -> slice .

    PLUS            reduce using rule 34 (expression -> slice .)
    MINUS           reduce using rule 34 (expression -> slice .)
    MULTIPLY        reduce using rule 34 (expression -> slice .)
    DIVIDE          reduce using rule 34 (expression -> slice .)
    POWER           reduce using rule 34 (expression -> slice .)
    LT              reduce using rule 34 (expression -> slice .)
    LE              reduce using rule 34 (expression -> slice .)
    GT              reduce using rule 34 (expression -> slice .)
    GE              reduce using rule 34 (expression -> slice .)
    EQUALS          reduce using rule 34 (expression -> slice .)
    NE              reduce using rule 34 (expression -> slice .)
    import          reduce using rule 34 (expression -> slice .)
    outcsv          reduce using rule 34 (expression -> slice .)
    save            reduce using rule 34 (expression -> slice .)
    search          reduce using rule 34 (expression -> slice .)
    foreach         reduce using rule 34 (expression -> slice .)
    end             reduce using rule 34 (expression -> slice .)
    return          reduce using rule 34 (expression -> slice .)
    continue        reduce using rule 34 (expression -> slice .)
    if              reduce using rule 34 (expression -> slice .)
    else            reduce using rule 34 (expression -> slice .)
    def             reduce using rule 34 (expression -> slice .)
    connect         reduce using rule 34 (expression -> slice .)
    let             reduce using rule 34 (expression -> slice .)
    list            reduce using rule 34 (expression -> slice .)
    ID              reduce using rule 34 (expression -> slice .)
    $end            reduce using rule 34 (expression -> slice .)
    RPAREN          reduce using rule 34 (expression -> slice .)
    COMMA           reduce using rule 34 (expression -> slice .)
    COLON           reduce using rule 34 (expression -> slice .)
    RQPAREN         reduce using rule 34 (expression -> slice .)
    then            reduce using rule 34 (expression -> slice .)


state 29

    (36) expression -> LPAREN . expression RPAREN
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 51

state 30

    (28) expression -> variable .

    PLUS            reduce using rule 28 (expression -> variable .)
    MINUS           reduce using rule 28 (expression -> variable .)
    MULTIPLY        reduce using rule 28 (expression -> variable .)
    DIVIDE          reduce using rule 28 (expression -> variable .)
    POWER           reduce using rule 28 (expression -> variable .)
    LT              reduce using rule 28 (expression -> variable .)
    LE              reduce using rule 28 (expression -> variable .)
    GT              reduce using rule 28 (expression -> variable .)
    GE              reduce using rule 28 (expression -> variable .)
    EQUALS          reduce using rule 28 (expression -> variable .)
    NE              reduce using rule 28 (expression -> variable .)
    import          reduce using rule 28 (expression -> variable .)
    outcsv          reduce using rule 28 (expression -> variable .)
    save            reduce using rule 28 (expression -> variable .)
    search          reduce using rule 28 (expression -> variable .)
    foreach         reduce using rule 28 (expression -> variable .)
    end             reduce using rule 28 (expression -> variable .)
    return          reduce using rule 28 (expression -> variable .)
    continue        reduce using rule 28 (expression -> variable .)
    if              reduce using rule 28 (expression -> variable .)
    else            reduce using rule 28 (expression -> variable .)
    def             reduce using rule 28 (expression -> variable .)
    connect         reduce using rule 28 (expression -> variable .)
    let             reduce using rule 28 (expression -> variable .)
    list            reduce using rule 28 (expression -> variable .)
    ID              reduce using rule 28 (expression -> variable .)
    $end            reduce using rule 28 (expression -> variable .)
    RPAREN          reduce using rule 28 (expression -> variable .)
    COMMA           reduce using rule 28 (expression -> variable .)
    COLON           reduce using rule 28 (expression -> variable .)
    RQPAREN         reduce using rule 28 (expression -> variable .)
    then            reduce using rule 28 (expression -> variable .)


state 31

    (54) variable -> ID .
    (48) function -> ID . LPAREN parlist RPAREN
    (49) function -> ID . LPAREN RPAREN
    (50) slice -> ID . LQPAREN expression COLON expression RQPAREN
    (51) slice -> ID . LQPAREN COLON expression RQPAREN
    (52) slice -> ID . LQPAREN expression COLON RQPAREN
    (53) slice -> ID . LQPAREN expression RQPAREN

    PLUS            reduce using rule 54 (variable -> ID .)
    MINUS           reduce using rule 54 (variable -> ID .)
    MULTIPLY        reduce using rule 54 (variable -> ID .)
    DIVIDE          reduce using rule 54 (variable -> ID .)
    POWER           reduce using rule 54 (variable -> ID .)
    RPAREN          reduce using rule 54 (variable -> ID .)
    COMMA           reduce using rule 54 (variable -> ID .)
    LT              reduce using rule 54 (variable -> ID .)
    LE              reduce using rule 54 (variable -> ID .)
    GT              reduce using rule 54 (variable -> ID .)
    GE              reduce using rule 54 (variable -> ID .)
    EQUALS          reduce using rule 54 (variable -> ID .)
    NE              reduce using rule 54 (variable -> ID .)
    import          reduce using rule 54 (variable -> ID .)
    outcsv          reduce using rule 54 (variable -> ID .)
    save            reduce using rule 54 (variable -> ID .)
    search          reduce using rule 54 (variable -> ID .)
    foreach         reduce using rule 54 (variable -> ID .)
    end             reduce using rule 54 (variable -> ID .)
    return          reduce using rule 54 (variable -> ID .)
    continue        reduce using rule 54 (variable -> ID .)
    if              reduce using rule 54 (variable -> ID .)
    else            reduce using rule 54 (variable -> ID .)
    def             reduce using rule 54 (variable -> ID .)
    connect         reduce using rule 54 (variable -> ID .)
    let             reduce using rule 54 (variable -> ID .)
    list            reduce using rule 54 (variable -> ID .)
    ID              reduce using rule 54 (variable -> ID .)
    $end            reduce using rule 54 (variable -> ID .)
    COLON           reduce using rule 54 (variable -> ID .)
    RQPAREN         reduce using rule 54 (variable -> ID .)
    then            reduce using rule 54 (variable -> ID .)
    LPAREN          shift and go to state 44
    LQPAREN         shift and go to state 52


state 32

    (30) expression -> FLOAT .

    PLUS            reduce using rule 30 (expression -> FLOAT .)
    MINUS           reduce using rule 30 (expression -> FLOAT .)
    MULTIPLY        reduce using rule 30 (expression -> FLOAT .)
    DIVIDE          reduce using rule 30 (expression -> FLOAT .)
    POWER           reduce using rule 30 (expression -> FLOAT .)
    LT              reduce using rule 30 (expression -> FLOAT .)
    LE              reduce using rule 30 (expression -> FLOAT .)
    GT              reduce using rule 30 (expression -> FLOAT .)
    GE              reduce using rule 30 (expression -> FLOAT .)
    EQUALS          reduce using rule 30 (expression -> FLOAT .)
    NE              reduce using rule 30 (expression -> FLOAT .)
    import          reduce using rule 30 (expression -> FLOAT .)
    outcsv          reduce using rule 30 (expression -> FLOAT .)
    save            reduce using rule 30 (expression -> FLOAT .)
    search          reduce using rule 30 (expression -> FLOAT .)
    foreach         reduce using rule 30 (expression -> FLOAT .)
    end             reduce using rule 30 (expression -> FLOAT .)
    return          reduce using rule 30 (expression -> FLOAT .)
    continue        reduce using rule 30 (expression -> FLOAT .)
    if              reduce using rule 30 (expression -> FLOAT .)
    else            reduce using rule 30 (expression -> FLOAT .)
    def             reduce using rule 30 (expression -> FLOAT .)
    connect         reduce using rule 30 (expression -> FLOAT .)
    let             reduce using rule 30 (expression -> FLOAT .)
    list            reduce using rule 30 (expression -> FLOAT .)
    ID              reduce using rule 30 (expression -> FLOAT .)
    $end            reduce using rule 30 (expression -> FLOAT .)
    RPAREN          reduce using rule 30 (expression -> FLOAT .)
    COMMA           reduce using rule 30 (expression -> FLOAT .)
    COLON           reduce using rule 30 (expression -> FLOAT .)
    RQPAREN         reduce using rule 30 (expression -> FLOAT .)
    then            reduce using rule 30 (expression -> FLOAT .)


state 33

    (42) relexpression -> expression . LT expression
    (43) relexpression -> expression . LE expression
    (44) relexpression -> expression . GT expression
    (45) relexpression -> expression . GE expression
    (46) relexpression -> expression . EQUALS expression
    (47) relexpression -> expression . NE expression
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    LT              shift and go to state 59
    LE              shift and go to state 53
    GT              shift and go to state 60
    GE              shift and go to state 54
    EQUALS          shift and go to state 57
    NE              shift and go to state 58
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 34

    (7) command -> outcsv ID . in STRING

    in              shift and go to state 64


state 35

    (3) program -> program function .

    import          reduce using rule 3 (program -> program function .)
    outcsv          reduce using rule 3 (program -> program function .)
    save            reduce using rule 3 (program -> program function .)
    search          reduce using rule 3 (program -> program function .)
    foreach         reduce using rule 3 (program -> program function .)
    end             reduce using rule 3 (program -> program function .)
    return          reduce using rule 3 (program -> program function .)
    continue        reduce using rule 3 (program -> program function .)
    if              reduce using rule 3 (program -> program function .)
    else            reduce using rule 3 (program -> program function .)
    def             reduce using rule 3 (program -> program function .)
    connect         reduce using rule 3 (program -> program function .)
    let             reduce using rule 3 (program -> program function .)
    list            reduce using rule 3 (program -> program function .)
    ID              reduce using rule 3 (program -> program function .)
    $end            reduce using rule 3 (program -> program function .)


state 36

    (1) program -> program command .

    import          reduce using rule 1 (program -> program command .)
    outcsv          reduce using rule 1 (program -> program command .)
    save            reduce using rule 1 (program -> program command .)
    search          reduce using rule 1 (program -> program command .)
    foreach         reduce using rule 1 (program -> program command .)
    end             reduce using rule 1 (program -> program command .)
    return          reduce using rule 1 (program -> program command .)
    continue        reduce using rule 1 (program -> program command .)
    if              reduce using rule 1 (program -> program command .)
    else            reduce using rule 1 (program -> program command .)
    def             reduce using rule 1 (program -> program command .)
    connect         reduce using rule 1 (program -> program command .)
    let             reduce using rule 1 (program -> program command .)
    list            reduce using rule 1 (program -> program command .)
    ID              reduce using rule 1 (program -> program command .)
    $end            reduce using rule 1 (program -> program command .)


state 37

    (11) command -> foreach ID . in ID
    (12) command -> foreach ID . COMMA ID in ID

    in              shift and go to state 65
    COMMA           shift and go to state 66


state 38

    (6) command -> import STRING .

    import          reduce using rule 6 (command -> import STRING .)
    outcsv          reduce using rule 6 (command -> import STRING .)
    save            reduce using rule 6 (command -> import STRING .)
    search          reduce using rule 6 (command -> import STRING .)
    foreach         reduce using rule 6 (command -> import STRING .)
    end             reduce using rule 6 (command -> import STRING .)
    return          reduce using rule 6 (command -> import STRING .)
    continue        reduce using rule 6 (command -> import STRING .)
    if              reduce using rule 6 (command -> import STRING .)
    else            reduce using rule 6 (command -> import STRING .)
    def             reduce using rule 6 (command -> import STRING .)
    connect         reduce using rule 6 (command -> import STRING .)
    let             reduce using rule 6 (command -> import STRING .)
    list            reduce using rule 6 (command -> import STRING .)
    ID              reduce using rule 6 (command -> import STRING .)
    $end            reduce using rule 6 (command -> import STRING .)


state 39

    (9) command -> save LPAREN . parlist RPAREN in ID
    (56) parlist -> . parlist COMMA expression
    (57) parlist -> . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    parlist                        shift and go to state 67
    variable                       shift and go to state 30
    expression                     shift and go to state 68

state 40

    (8) command -> save ID . in ID

    in              shift and go to state 69


state 41

    (15) command -> return expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    import          reduce using rule 15 (command -> return expression .)
    outcsv          reduce using rule 15 (command -> return expression .)
    save            reduce using rule 15 (command -> return expression .)
    search          reduce using rule 15 (command -> return expression .)
    foreach         reduce using rule 15 (command -> return expression .)
    end             reduce using rule 15 (command -> return expression .)
    return          reduce using rule 15 (command -> return expression .)
    continue        reduce using rule 15 (command -> return expression .)
    if              reduce using rule 15 (command -> return expression .)
    else            reduce using rule 15 (command -> return expression .)
    def             reduce using rule 15 (command -> return expression .)
    connect         reduce using rule 15 (command -> return expression .)
    let             reduce using rule 15 (command -> return expression .)
    list            reduce using rule 15 (command -> return expression .)
    ID              reduce using rule 15 (command -> return expression .)
    $end            reduce using rule 15 (command -> return expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 42

    (23) command -> let error .

    import          reduce using rule 23 (command -> let error .)
    outcsv          reduce using rule 23 (command -> let error .)
    save            reduce using rule 23 (command -> let error .)
    search          reduce using rule 23 (command -> let error .)
    foreach         reduce using rule 23 (command -> let error .)
    end             reduce using rule 23 (command -> let error .)
    return          reduce using rule 23 (command -> let error .)
    continue        reduce using rule 23 (command -> let error .)
    if              reduce using rule 23 (command -> let error .)
    else            reduce using rule 23 (command -> let error .)
    def             reduce using rule 23 (command -> let error .)
    connect         reduce using rule 23 (command -> let error .)
    let             reduce using rule 23 (command -> let error .)
    list            reduce using rule 23 (command -> let error .)
    ID              reduce using rule 23 (command -> let error .)
    $end            reduce using rule 23 (command -> let error .)


state 43

    (22) command -> let ID . EQUALS expression

    EQUALS          shift and go to state 70


state 44

    (48) function -> ID LPAREN . parlist RPAREN
    (49) function -> ID LPAREN . RPAREN
    (56) parlist -> . parlist COMMA expression
    (57) parlist -> . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    RPAREN          shift and go to state 72
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    parlist                        shift and go to state 71
    variable                       shift and go to state 30
    expression                     shift and go to state 68

state 45

    (10) command -> search ID . with ID as sql

    with            shift and go to state 73


state 46

    (24) command -> list ID . EQUALS LPAREN parlist RPAREN

    EQUALS          shift and go to state 74


state 47

    (19) command -> def ID . LPAREN RPAREN
    (20) command -> def ID . LPAREN parlist RPAREN

    LPAREN          shift and go to state 75


state 48

    (21) command -> connect ID EQUALS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 76

state 49

    (35) expression -> MINUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 35 (expression -> MINUS expression .)
    MINUS           reduce using rule 35 (expression -> MINUS expression .)
    MULTIPLY        reduce using rule 35 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 35 (expression -> MINUS expression .)
    POWER           reduce using rule 35 (expression -> MINUS expression .)
    LT              reduce using rule 35 (expression -> MINUS expression .)
    LE              reduce using rule 35 (expression -> MINUS expression .)
    GT              reduce using rule 35 (expression -> MINUS expression .)
    GE              reduce using rule 35 (expression -> MINUS expression .)
    EQUALS          reduce using rule 35 (expression -> MINUS expression .)
    NE              reduce using rule 35 (expression -> MINUS expression .)
    import          reduce using rule 35 (expression -> MINUS expression .)
    outcsv          reduce using rule 35 (expression -> MINUS expression .)
    save            reduce using rule 35 (expression -> MINUS expression .)
    search          reduce using rule 35 (expression -> MINUS expression .)
    foreach         reduce using rule 35 (expression -> MINUS expression .)
    end             reduce using rule 35 (expression -> MINUS expression .)
    return          reduce using rule 35 (expression -> MINUS expression .)
    continue        reduce using rule 35 (expression -> MINUS expression .)
    if              reduce using rule 35 (expression -> MINUS expression .)
    else            reduce using rule 35 (expression -> MINUS expression .)
    def             reduce using rule 35 (expression -> MINUS expression .)
    connect         reduce using rule 35 (expression -> MINUS expression .)
    let             reduce using rule 35 (expression -> MINUS expression .)
    list            reduce using rule 35 (expression -> MINUS expression .)
    ID              reduce using rule 35 (expression -> MINUS expression .)
    $end            reduce using rule 35 (expression -> MINUS expression .)
    RPAREN          reduce using rule 35 (expression -> MINUS expression .)
    COMMA           reduce using rule 35 (expression -> MINUS expression .)
    COLON           reduce using rule 35 (expression -> MINUS expression .)
    RQPAREN         reduce using rule 35 (expression -> MINUS expression .)
    then            reduce using rule 35 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MULTIPLY        [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 55 ]
  ! POWER           [ shift and go to state 56 ]


state 50

    (17) command -> if relexpression then .

    import          reduce using rule 17 (command -> if relexpression then .)
    outcsv          reduce using rule 17 (command -> if relexpression then .)
    save            reduce using rule 17 (command -> if relexpression then .)
    search          reduce using rule 17 (command -> if relexpression then .)
    foreach         reduce using rule 17 (command -> if relexpression then .)
    end             reduce using rule 17 (command -> if relexpression then .)
    return          reduce using rule 17 (command -> if relexpression then .)
    continue        reduce using rule 17 (command -> if relexpression then .)
    if              reduce using rule 17 (command -> if relexpression then .)
    else            reduce using rule 17 (command -> if relexpression then .)
    def             reduce using rule 17 (command -> if relexpression then .)
    connect         reduce using rule 17 (command -> if relexpression then .)
    let             reduce using rule 17 (command -> if relexpression then .)
    list            reduce using rule 17 (command -> if relexpression then .)
    ID              reduce using rule 17 (command -> if relexpression then .)
    $end            reduce using rule 17 (command -> if relexpression then .)


state 51

    (36) expression -> LPAREN expression . RPAREN
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          shift and go to state 77
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 52

    (50) slice -> ID LQPAREN . expression COLON expression RQPAREN
    (51) slice -> ID LQPAREN . COLON expression RQPAREN
    (52) slice -> ID LQPAREN . expression COLON RQPAREN
    (53) slice -> ID LQPAREN . expression RQPAREN
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    COLON           shift and go to state 78
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 79

state 53

    (43) relexpression -> expression LE . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 80

state 54

    (45) relexpression -> expression GE . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 81

state 55

    (40) expression -> expression DIVIDE . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 82

state 56

    (41) expression -> expression POWER . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 83

state 57

    (46) relexpression -> expression EQUALS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 84

state 58

    (47) relexpression -> expression NE . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 85

state 59

    (42) relexpression -> expression LT . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 86

state 60

    (44) relexpression -> expression GT . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 87

state 61

    (37) expression -> expression PLUS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 88

state 62

    (39) expression -> expression MULTIPLY . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 89

state 63

    (38) expression -> expression MINUS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 90

state 64

    (7) command -> outcsv ID in . STRING

    STRING          shift and go to state 91


state 65

    (11) command -> foreach ID in . ID

    ID              shift and go to state 92


state 66

    (12) command -> foreach ID COMMA . ID in ID

    ID              shift and go to state 93


state 67

    (9) command -> save LPAREN parlist . RPAREN in ID
    (56) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 94
    COMMA           shift and go to state 95


state 68

    (57) parlist -> expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          reduce using rule 57 (parlist -> expression .)
    COMMA           reduce using rule 57 (parlist -> expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 69

    (8) command -> save ID in . ID

    ID              shift and go to state 96


state 70

    (22) command -> let ID EQUALS . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 97

state 71

    (48) function -> ID LPAREN parlist . RPAREN
    (56) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 98
    COMMA           shift and go to state 95


state 72

    (49) function -> ID LPAREN RPAREN .

    PLUS            reduce using rule 49 (function -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 49 (function -> ID LPAREN RPAREN .)
    MULTIPLY        reduce using rule 49 (function -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    POWER           reduce using rule 49 (function -> ID LPAREN RPAREN .)
    LT              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    LE              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    GT              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    GE              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    EQUALS          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    NE              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    import          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    outcsv          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    save            reduce using rule 49 (function -> ID LPAREN RPAREN .)
    search          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    foreach         reduce using rule 49 (function -> ID LPAREN RPAREN .)
    end             reduce using rule 49 (function -> ID LPAREN RPAREN .)
    return          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    continue        reduce using rule 49 (function -> ID LPAREN RPAREN .)
    if              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    else            reduce using rule 49 (function -> ID LPAREN RPAREN .)
    def             reduce using rule 49 (function -> ID LPAREN RPAREN .)
    connect         reduce using rule 49 (function -> ID LPAREN RPAREN .)
    let             reduce using rule 49 (function -> ID LPAREN RPAREN .)
    list            reduce using rule 49 (function -> ID LPAREN RPAREN .)
    ID              reduce using rule 49 (function -> ID LPAREN RPAREN .)
    $end            reduce using rule 49 (function -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 49 (function -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 49 (function -> ID LPAREN RPAREN .)
    COLON           reduce using rule 49 (function -> ID LPAREN RPAREN .)
    RQPAREN         reduce using rule 49 (function -> ID LPAREN RPAREN .)
    then            reduce using rule 49 (function -> ID LPAREN RPAREN .)


state 73

    (10) command -> search ID with . ID as sql

    ID              shift and go to state 99


state 74

    (24) command -> list ID EQUALS . LPAREN parlist RPAREN

    LPAREN          shift and go to state 100


state 75

    (19) command -> def ID LPAREN . RPAREN
    (20) command -> def ID LPAREN . parlist RPAREN
    (56) parlist -> . parlist COMMA expression
    (57) parlist -> . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    RPAREN          shift and go to state 102
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    parlist                        shift and go to state 101
    variable                       shift and go to state 30
    expression                     shift and go to state 68

state 76

    (21) command -> connect ID EQUALS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    import          reduce using rule 21 (command -> connect ID EQUALS expression .)
    outcsv          reduce using rule 21 (command -> connect ID EQUALS expression .)
    save            reduce using rule 21 (command -> connect ID EQUALS expression .)
    search          reduce using rule 21 (command -> connect ID EQUALS expression .)
    foreach         reduce using rule 21 (command -> connect ID EQUALS expression .)
    end             reduce using rule 21 (command -> connect ID EQUALS expression .)
    return          reduce using rule 21 (command -> connect ID EQUALS expression .)
    continue        reduce using rule 21 (command -> connect ID EQUALS expression .)
    if              reduce using rule 21 (command -> connect ID EQUALS expression .)
    else            reduce using rule 21 (command -> connect ID EQUALS expression .)
    def             reduce using rule 21 (command -> connect ID EQUALS expression .)
    connect         reduce using rule 21 (command -> connect ID EQUALS expression .)
    let             reduce using rule 21 (command -> connect ID EQUALS expression .)
    list            reduce using rule 21 (command -> connect ID EQUALS expression .)
    ID              reduce using rule 21 (command -> connect ID EQUALS expression .)
    $end            reduce using rule 21 (command -> connect ID EQUALS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 77

    (36) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    POWER           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    EQUALS          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    import          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    outcsv          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    save            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    search          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    foreach         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    end             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    return          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    continue        reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    if              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    else            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    def             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    connect         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    let             reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    list            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    ID              reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    $end            reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    RQPAREN         reduce using rule 36 (expression -> LPAREN expression RPAREN .)
    then            reduce using rule 36 (expression -> LPAREN expression RPAREN .)


state 78

    (51) slice -> ID LQPAREN COLON . expression RQPAREN
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 103

state 79

    (50) slice -> ID LQPAREN expression . COLON expression RQPAREN
    (52) slice -> ID LQPAREN expression . COLON RQPAREN
    (53) slice -> ID LQPAREN expression . RQPAREN
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    COLON           shift and go to state 105
    RQPAREN         shift and go to state 104
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 80

    (43) relexpression -> expression LE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 43 (relexpression -> expression LE expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 81

    (45) relexpression -> expression GE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 45 (relexpression -> expression GE expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 82

    (40) expression -> expression DIVIDE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 40 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 40 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 40 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 40 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 40 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 40 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 40 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 40 (expression -> expression DIVIDE expression .)
    import          reduce using rule 40 (expression -> expression DIVIDE expression .)
    outcsv          reduce using rule 40 (expression -> expression DIVIDE expression .)
    save            reduce using rule 40 (expression -> expression DIVIDE expression .)
    search          reduce using rule 40 (expression -> expression DIVIDE expression .)
    foreach         reduce using rule 40 (expression -> expression DIVIDE expression .)
    end             reduce using rule 40 (expression -> expression DIVIDE expression .)
    return          reduce using rule 40 (expression -> expression DIVIDE expression .)
    continue        reduce using rule 40 (expression -> expression DIVIDE expression .)
    if              reduce using rule 40 (expression -> expression DIVIDE expression .)
    else            reduce using rule 40 (expression -> expression DIVIDE expression .)
    def             reduce using rule 40 (expression -> expression DIVIDE expression .)
    connect         reduce using rule 40 (expression -> expression DIVIDE expression .)
    let             reduce using rule 40 (expression -> expression DIVIDE expression .)
    list            reduce using rule 40 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 40 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 40 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 40 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 40 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 40 (expression -> expression DIVIDE expression .)
    RQPAREN         reduce using rule 40 (expression -> expression DIVIDE expression .)
    then            reduce using rule 40 (expression -> expression DIVIDE expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 40 (expression -> expression DIVIDE expression .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MULTIPLY        [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 55 ]


state 83

    (41) expression -> expression POWER expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 41 (expression -> expression POWER expression .)
    MINUS           reduce using rule 41 (expression -> expression POWER expression .)
    MULTIPLY        reduce using rule 41 (expression -> expression POWER expression .)
    DIVIDE          reduce using rule 41 (expression -> expression POWER expression .)
    POWER           reduce using rule 41 (expression -> expression POWER expression .)
    LT              reduce using rule 41 (expression -> expression POWER expression .)
    LE              reduce using rule 41 (expression -> expression POWER expression .)
    GT              reduce using rule 41 (expression -> expression POWER expression .)
    GE              reduce using rule 41 (expression -> expression POWER expression .)
    EQUALS          reduce using rule 41 (expression -> expression POWER expression .)
    NE              reduce using rule 41 (expression -> expression POWER expression .)
    import          reduce using rule 41 (expression -> expression POWER expression .)
    outcsv          reduce using rule 41 (expression -> expression POWER expression .)
    save            reduce using rule 41 (expression -> expression POWER expression .)
    search          reduce using rule 41 (expression -> expression POWER expression .)
    foreach         reduce using rule 41 (expression -> expression POWER expression .)
    end             reduce using rule 41 (expression -> expression POWER expression .)
    return          reduce using rule 41 (expression -> expression POWER expression .)
    continue        reduce using rule 41 (expression -> expression POWER expression .)
    if              reduce using rule 41 (expression -> expression POWER expression .)
    else            reduce using rule 41 (expression -> expression POWER expression .)
    def             reduce using rule 41 (expression -> expression POWER expression .)
    connect         reduce using rule 41 (expression -> expression POWER expression .)
    let             reduce using rule 41 (expression -> expression POWER expression .)
    list            reduce using rule 41 (expression -> expression POWER expression .)
    ID              reduce using rule 41 (expression -> expression POWER expression .)
    $end            reduce using rule 41 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 41 (expression -> expression POWER expression .)
    COMMA           reduce using rule 41 (expression -> expression POWER expression .)
    COLON           reduce using rule 41 (expression -> expression POWER expression .)
    RQPAREN         reduce using rule 41 (expression -> expression POWER expression .)
    then            reduce using rule 41 (expression -> expression POWER expression .)

  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MULTIPLY        [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 55 ]
  ! POWER           [ shift and go to state 56 ]


state 84

    (46) relexpression -> expression EQUALS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 46 (relexpression -> expression EQUALS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 85

    (47) relexpression -> expression NE expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 47 (relexpression -> expression NE expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 86

    (42) relexpression -> expression LT expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 42 (relexpression -> expression LT expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 87

    (44) relexpression -> expression GT expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    then            reduce using rule 44 (relexpression -> expression GT expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 88

    (37) expression -> expression PLUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 37 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 37 (expression -> expression PLUS expression .)
    LT              reduce using rule 37 (expression -> expression PLUS expression .)
    LE              reduce using rule 37 (expression -> expression PLUS expression .)
    GT              reduce using rule 37 (expression -> expression PLUS expression .)
    GE              reduce using rule 37 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 37 (expression -> expression PLUS expression .)
    NE              reduce using rule 37 (expression -> expression PLUS expression .)
    import          reduce using rule 37 (expression -> expression PLUS expression .)
    outcsv          reduce using rule 37 (expression -> expression PLUS expression .)
    save            reduce using rule 37 (expression -> expression PLUS expression .)
    search          reduce using rule 37 (expression -> expression PLUS expression .)
    foreach         reduce using rule 37 (expression -> expression PLUS expression .)
    end             reduce using rule 37 (expression -> expression PLUS expression .)
    return          reduce using rule 37 (expression -> expression PLUS expression .)
    continue        reduce using rule 37 (expression -> expression PLUS expression .)
    if              reduce using rule 37 (expression -> expression PLUS expression .)
    else            reduce using rule 37 (expression -> expression PLUS expression .)
    def             reduce using rule 37 (expression -> expression PLUS expression .)
    connect         reduce using rule 37 (expression -> expression PLUS expression .)
    let             reduce using rule 37 (expression -> expression PLUS expression .)
    list            reduce using rule 37 (expression -> expression PLUS expression .)
    ID              reduce using rule 37 (expression -> expression PLUS expression .)
    $end            reduce using rule 37 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 37 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 37 (expression -> expression PLUS expression .)
    COLON           reduce using rule 37 (expression -> expression PLUS expression .)
    RQPAREN         reduce using rule 37 (expression -> expression PLUS expression .)
    then            reduce using rule 37 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56

  ! MULTIPLY        [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 37 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]


state 89

    (39) expression -> expression MULTIPLY expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 39 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 39 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    LT              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    LE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    GT              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    GE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    EQUALS          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    NE              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    import          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    outcsv          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    save            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    search          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    foreach         reduce using rule 39 (expression -> expression MULTIPLY expression .)
    end             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    return          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    continue        reduce using rule 39 (expression -> expression MULTIPLY expression .)
    if              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    else            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    def             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    connect         reduce using rule 39 (expression -> expression MULTIPLY expression .)
    let             reduce using rule 39 (expression -> expression MULTIPLY expression .)
    list            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    ID              reduce using rule 39 (expression -> expression MULTIPLY expression .)
    $end            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 39 (expression -> expression MULTIPLY expression .)
    COMMA           reduce using rule 39 (expression -> expression MULTIPLY expression .)
    COLON           reduce using rule 39 (expression -> expression MULTIPLY expression .)
    RQPAREN         reduce using rule 39 (expression -> expression MULTIPLY expression .)
    then            reduce using rule 39 (expression -> expression MULTIPLY expression .)
    POWER           shift and go to state 56

  ! POWER           [ reduce using rule 39 (expression -> expression MULTIPLY expression .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]
  ! MULTIPLY        [ shift and go to state 62 ]
  ! DIVIDE          [ shift and go to state 55 ]


state 90

    (38) expression -> expression MINUS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    PLUS            reduce using rule 38 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 38 (expression -> expression MINUS expression .)
    LT              reduce using rule 38 (expression -> expression MINUS expression .)
    LE              reduce using rule 38 (expression -> expression MINUS expression .)
    GT              reduce using rule 38 (expression -> expression MINUS expression .)
    GE              reduce using rule 38 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 38 (expression -> expression MINUS expression .)
    NE              reduce using rule 38 (expression -> expression MINUS expression .)
    import          reduce using rule 38 (expression -> expression MINUS expression .)
    outcsv          reduce using rule 38 (expression -> expression MINUS expression .)
    save            reduce using rule 38 (expression -> expression MINUS expression .)
    search          reduce using rule 38 (expression -> expression MINUS expression .)
    foreach         reduce using rule 38 (expression -> expression MINUS expression .)
    end             reduce using rule 38 (expression -> expression MINUS expression .)
    return          reduce using rule 38 (expression -> expression MINUS expression .)
    continue        reduce using rule 38 (expression -> expression MINUS expression .)
    if              reduce using rule 38 (expression -> expression MINUS expression .)
    else            reduce using rule 38 (expression -> expression MINUS expression .)
    def             reduce using rule 38 (expression -> expression MINUS expression .)
    connect         reduce using rule 38 (expression -> expression MINUS expression .)
    let             reduce using rule 38 (expression -> expression MINUS expression .)
    list            reduce using rule 38 (expression -> expression MINUS expression .)
    ID              reduce using rule 38 (expression -> expression MINUS expression .)
    $end            reduce using rule 38 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 38 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 38 (expression -> expression MINUS expression .)
    COLON           reduce using rule 38 (expression -> expression MINUS expression .)
    RQPAREN         reduce using rule 38 (expression -> expression MINUS expression .)
    then            reduce using rule 38 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56

  ! MULTIPLY        [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 38 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 61 ]
  ! MINUS           [ shift and go to state 63 ]


state 91

    (7) command -> outcsv ID in STRING .

    import          reduce using rule 7 (command -> outcsv ID in STRING .)
    outcsv          reduce using rule 7 (command -> outcsv ID in STRING .)
    save            reduce using rule 7 (command -> outcsv ID in STRING .)
    search          reduce using rule 7 (command -> outcsv ID in STRING .)
    foreach         reduce using rule 7 (command -> outcsv ID in STRING .)
    end             reduce using rule 7 (command -> outcsv ID in STRING .)
    return          reduce using rule 7 (command -> outcsv ID in STRING .)
    continue        reduce using rule 7 (command -> outcsv ID in STRING .)
    if              reduce using rule 7 (command -> outcsv ID in STRING .)
    else            reduce using rule 7 (command -> outcsv ID in STRING .)
    def             reduce using rule 7 (command -> outcsv ID in STRING .)
    connect         reduce using rule 7 (command -> outcsv ID in STRING .)
    let             reduce using rule 7 (command -> outcsv ID in STRING .)
    list            reduce using rule 7 (command -> outcsv ID in STRING .)
    ID              reduce using rule 7 (command -> outcsv ID in STRING .)
    $end            reduce using rule 7 (command -> outcsv ID in STRING .)


state 92

    (11) command -> foreach ID in ID .

    import          reduce using rule 11 (command -> foreach ID in ID .)
    outcsv          reduce using rule 11 (command -> foreach ID in ID .)
    save            reduce using rule 11 (command -> foreach ID in ID .)
    search          reduce using rule 11 (command -> foreach ID in ID .)
    foreach         reduce using rule 11 (command -> foreach ID in ID .)
    end             reduce using rule 11 (command -> foreach ID in ID .)
    return          reduce using rule 11 (command -> foreach ID in ID .)
    continue        reduce using rule 11 (command -> foreach ID in ID .)
    if              reduce using rule 11 (command -> foreach ID in ID .)
    else            reduce using rule 11 (command -> foreach ID in ID .)
    def             reduce using rule 11 (command -> foreach ID in ID .)
    connect         reduce using rule 11 (command -> foreach ID in ID .)
    let             reduce using rule 11 (command -> foreach ID in ID .)
    list            reduce using rule 11 (command -> foreach ID in ID .)
    ID              reduce using rule 11 (command -> foreach ID in ID .)
    $end            reduce using rule 11 (command -> foreach ID in ID .)


state 93

    (12) command -> foreach ID COMMA ID . in ID

    in              shift and go to state 106


state 94

    (9) command -> save LPAREN parlist RPAREN . in ID

    in              shift and go to state 107


state 95

    (56) parlist -> parlist COMMA . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 108

state 96

    (8) command -> save ID in ID .

    import          reduce using rule 8 (command -> save ID in ID .)
    outcsv          reduce using rule 8 (command -> save ID in ID .)
    save            reduce using rule 8 (command -> save ID in ID .)
    search          reduce using rule 8 (command -> save ID in ID .)
    foreach         reduce using rule 8 (command -> save ID in ID .)
    end             reduce using rule 8 (command -> save ID in ID .)
    return          reduce using rule 8 (command -> save ID in ID .)
    continue        reduce using rule 8 (command -> save ID in ID .)
    if              reduce using rule 8 (command -> save ID in ID .)
    else            reduce using rule 8 (command -> save ID in ID .)
    def             reduce using rule 8 (command -> save ID in ID .)
    connect         reduce using rule 8 (command -> save ID in ID .)
    let             reduce using rule 8 (command -> save ID in ID .)
    list            reduce using rule 8 (command -> save ID in ID .)
    ID              reduce using rule 8 (command -> save ID in ID .)
    $end            reduce using rule 8 (command -> save ID in ID .)


state 97

    (22) command -> let ID EQUALS expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    import          reduce using rule 22 (command -> let ID EQUALS expression .)
    outcsv          reduce using rule 22 (command -> let ID EQUALS expression .)
    save            reduce using rule 22 (command -> let ID EQUALS expression .)
    search          reduce using rule 22 (command -> let ID EQUALS expression .)
    foreach         reduce using rule 22 (command -> let ID EQUALS expression .)
    end             reduce using rule 22 (command -> let ID EQUALS expression .)
    return          reduce using rule 22 (command -> let ID EQUALS expression .)
    continue        reduce using rule 22 (command -> let ID EQUALS expression .)
    if              reduce using rule 22 (command -> let ID EQUALS expression .)
    else            reduce using rule 22 (command -> let ID EQUALS expression .)
    def             reduce using rule 22 (command -> let ID EQUALS expression .)
    connect         reduce using rule 22 (command -> let ID EQUALS expression .)
    let             reduce using rule 22 (command -> let ID EQUALS expression .)
    list            reduce using rule 22 (command -> let ID EQUALS expression .)
    ID              reduce using rule 22 (command -> let ID EQUALS expression .)
    $end            reduce using rule 22 (command -> let ID EQUALS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 98

    (48) function -> ID LPAREN parlist RPAREN .

    PLUS            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    MINUS           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    MULTIPLY        reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    DIVIDE          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    POWER           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    LT              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    LE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    GT              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    GE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    EQUALS          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    NE              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    import          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    save            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    search          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    end             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    return          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    continue        reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    if              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    else            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    def             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    connect         reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    let             reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    list            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    ID              reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    $end            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    RPAREN          reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    COMMA           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    COLON           reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    RQPAREN         reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)
    then            reduce using rule 48 (function -> ID LPAREN parlist RPAREN .)


state 99

    (10) command -> search ID with ID . as sql

    as              shift and go to state 109


state 100

    (24) command -> list ID EQUALS LPAREN . parlist RPAREN
    (56) parlist -> . parlist COMMA expression
    (57) parlist -> . expression
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    parlist                        shift and go to state 110
    variable                       shift and go to state 30
    expression                     shift and go to state 68

state 101

    (20) command -> def ID LPAREN parlist . RPAREN
    (56) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 111
    COMMA           shift and go to state 95


state 102

    (19) command -> def ID LPAREN RPAREN .

    import          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    outcsv          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    save            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    search          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    foreach         reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    end             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    return          reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    continue        reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    if              reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    else            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    def             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    connect         reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    let             reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    list            reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    ID              reduce using rule 19 (command -> def ID LPAREN RPAREN .)
    $end            reduce using rule 19 (command -> def ID LPAREN RPAREN .)


state 103

    (51) slice -> ID LQPAREN COLON expression . RQPAREN
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RQPAREN         shift and go to state 112
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 104

    (53) slice -> ID LQPAREN expression RQPAREN .

    RPAREN          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    PLUS            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    MINUS           reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    MULTIPLY        reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    DIVIDE          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    POWER           reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    then            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    COMMA           reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    LT              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    LE              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    GT              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    GE              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    EQUALS          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    NE              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    import          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    outcsv          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    save            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    search          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    foreach         reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    end             reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    return          reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    continue        reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    if              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    else            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    def             reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    connect         reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    let             reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    list            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    ID              reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    $end            reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    COLON           reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)
    RQPAREN         reduce using rule 53 (slice -> ID LQPAREN expression RQPAREN .)


state 105

    (50) slice -> ID LQPAREN expression COLON . expression RQPAREN
    (52) slice -> ID LQPAREN expression COLON . RQPAREN
    (28) expression -> . variable
    (29) expression -> . dbvariable
    (30) expression -> . FLOAT
    (31) expression -> . INTEGER
    (32) expression -> . STRING
    (33) expression -> . function
    (34) expression -> . slice
    (35) expression -> . MINUS expression
    (36) expression -> . LPAREN expression RPAREN
    (37) expression -> . expression PLUS expression
    (38) expression -> . expression MINUS expression
    (39) expression -> . expression MULTIPLY expression
    (40) expression -> . expression DIVIDE expression
    (41) expression -> . expression POWER expression
    (54) variable -> . ID
    (55) dbvariable -> . DBID
    (48) function -> . ID LPAREN parlist RPAREN
    (49) function -> . ID LPAREN RPAREN
    (50) slice -> . ID LQPAREN expression COLON expression RQPAREN
    (51) slice -> . ID LQPAREN COLON expression RQPAREN
    (52) slice -> . ID LQPAREN expression COLON RQPAREN
    (53) slice -> . ID LQPAREN expression RQPAREN

    RQPAREN         shift and go to state 113
    FLOAT           shift and go to state 32
    INTEGER         shift and go to state 24
    STRING          shift and go to state 26
    MINUS           shift and go to state 21
    LPAREN          shift and go to state 29
    ID              shift and go to state 31
    DBID            shift and go to state 23

    dbvariable                     shift and go to state 22
    function                       shift and go to state 25
    slice                          shift and go to state 28
    variable                       shift and go to state 30
    expression                     shift and go to state 114

state 106

    (12) command -> foreach ID COMMA ID in . ID

    ID              shift and go to state 115


state 107

    (9) command -> save LPAREN parlist RPAREN in . ID

    ID              shift and go to state 116


state 108

    (56) parlist -> parlist COMMA expression .
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RPAREN          reduce using rule 56 (parlist -> parlist COMMA expression .)
    COMMA           reduce using rule 56 (parlist -> parlist COMMA expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 109

    (10) command -> search ID with ID as . sql
    (25) sql -> . SELECT
    (26) sql -> . INSERT
    (27) sql -> . UPDATE

    SELECT          shift and go to state 120
    INSERT          shift and go to state 117
    UPDATE          shift and go to state 118

    sql                            shift and go to state 119

state 110

    (24) command -> list ID EQUALS LPAREN parlist . RPAREN
    (56) parlist -> parlist . COMMA expression

    RPAREN          shift and go to state 121
    COMMA           shift and go to state 95


state 111

    (20) command -> def ID LPAREN parlist RPAREN .

    import          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    outcsv          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    save            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    search          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    foreach         reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    end             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    return          reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    continue        reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    if              reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    else            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    def             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    connect         reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    let             reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    list            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    ID              reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)
    $end            reduce using rule 20 (command -> def ID LPAREN parlist RPAREN .)


state 112

    (51) slice -> ID LQPAREN COLON expression RQPAREN .

    RPAREN          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    PLUS            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    MINUS           reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    MULTIPLY        reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    DIVIDE          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    POWER           reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    then            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    COMMA           reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    LT              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    LE              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    GT              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    GE              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    EQUALS          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    NE              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    import          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    outcsv          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    save            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    search          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    foreach         reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    end             reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    return          reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    continue        reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    if              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    else            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    def             reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    connect         reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    let             reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    list            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    ID              reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    $end            reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    COLON           reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)
    RQPAREN         reduce using rule 51 (slice -> ID LQPAREN COLON expression RQPAREN .)


state 113

    (52) slice -> ID LQPAREN expression COLON RQPAREN .

    RPAREN          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    PLUS            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    MINUS           reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    MULTIPLY        reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    DIVIDE          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    POWER           reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    then            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    COMMA           reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    LT              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    LE              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    GT              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    GE              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    EQUALS          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    NE              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    import          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    outcsv          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    save            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    search          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    foreach         reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    end             reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    return          reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    continue        reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    if              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    else            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    def             reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    connect         reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    let             reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    list            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    ID              reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    $end            reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    COLON           reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)
    RQPAREN         reduce using rule 52 (slice -> ID LQPAREN expression COLON RQPAREN .)


state 114

    (50) slice -> ID LQPAREN expression COLON expression . RQPAREN
    (37) expression -> expression . PLUS expression
    (38) expression -> expression . MINUS expression
    (39) expression -> expression . MULTIPLY expression
    (40) expression -> expression . DIVIDE expression
    (41) expression -> expression . POWER expression

    RQPAREN         shift and go to state 122
    PLUS            shift and go to state 61
    MINUS           shift and go to state 63
    MULTIPLY        shift and go to state 62
    DIVIDE          shift and go to state 55
    POWER           shift and go to state 56


state 115

    (12) command -> foreach ID COMMA ID in ID .

    import          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    outcsv          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    save            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    search          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    foreach         reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    end             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    return          reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    continue        reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    if              reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    else            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    def             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    connect         reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    let             reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    list            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    ID              reduce using rule 12 (command -> foreach ID COMMA ID in ID .)
    $end            reduce using rule 12 (command -> foreach ID COMMA ID in ID .)


state 116

    (9) command -> save LPAREN parlist RPAREN in ID .

    import          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    outcsv          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    save            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    search          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    foreach         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    end             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    return          reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    continue        reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    if              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    else            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    def             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    connect         reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    let             reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    list            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    ID              reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)
    $end            reduce using rule 9 (command -> save LPAREN parlist RPAREN in ID .)


state 117

    (26) sql -> INSERT .

    import          reduce using rule 26 (sql -> INSERT .)
    outcsv          reduce using rule 26 (sql -> INSERT .)
    save            reduce using rule 26 (sql -> INSERT .)
    search          reduce using rule 26 (sql -> INSERT .)
    foreach         reduce using rule 26 (sql -> INSERT .)
    end             reduce using rule 26 (sql -> INSERT .)
    return          reduce using rule 26 (sql -> INSERT .)
    continue        reduce using rule 26 (sql -> INSERT .)
    if              reduce using rule 26 (sql -> INSERT .)
    else            reduce using rule 26 (sql -> INSERT .)
    def             reduce using rule 26 (sql -> INSERT .)
    connect         reduce using rule 26 (sql -> INSERT .)
    let             reduce using rule 26 (sql -> INSERT .)
    list            reduce using rule 26 (sql -> INSERT .)
    ID              reduce using rule 26 (sql -> INSERT .)
    $end            reduce using rule 26 (sql -> INSERT .)


state 118

    (27) sql -> UPDATE .

    import          reduce using rule 27 (sql -> UPDATE .)
    outcsv          reduce using rule 27 (sql -> UPDATE .)
    save            reduce using rule 27 (sql -> UPDATE .)
    search          reduce using rule 27 (sql -> UPDATE .)
    foreach         reduce using rule 27 (sql -> UPDATE .)
    end             reduce using rule 27 (sql -> UPDATE .)
    return          reduce using rule 27 (sql -> UPDATE .)
    continue        reduce using rule 27 (sql -> UPDATE .)
    if              reduce using rule 27 (sql -> UPDATE .)
    else            reduce using rule 27 (sql -> UPDATE .)
    def             reduce using rule 27 (sql -> UPDATE .)
    connect         reduce using rule 27 (sql -> UPDATE .)
    let             reduce using rule 27 (sql -> UPDATE .)
    list            reduce using rule 27 (sql -> UPDATE .)
    ID              reduce using rule 27 (sql -> UPDATE .)
    $end            reduce using rule 27 (sql -> UPDATE .)


state 119

    (10) command -> search ID with ID as sql .

    import          reduce using rule 10 (command -> search ID with ID as sql .)
    outcsv          reduce using rule 10 (command -> search ID with ID as sql .)
    save            reduce using rule 10 (command -> search ID with ID as sql .)
    search          reduce using rule 10 (command -> search ID with ID as sql .)
    foreach         reduce using rule 10 (command -> search ID with ID as sql .)
    end             reduce using rule 10 (command -> search ID with ID as sql .)
    return          reduce using rule 10 (command -> search ID with ID as sql .)
    continue        reduce using rule 10 (command -> search ID with ID as sql .)
    if              reduce using rule 10 (command -> search ID with ID as sql .)
    else            reduce using rule 10 (command -> search ID with ID as sql .)
    def             reduce using rule 10 (command -> search ID with ID as sql .)
    connect         reduce using rule 10 (command -> search ID with ID as sql .)
    let             reduce using rule 10 (command -> search ID with ID as sql .)
    list            reduce using rule 10 (command -> search ID with ID as sql .)
    ID              reduce using rule 10 (command -> search ID with ID as sql .)
    $end            reduce using rule 10 (command -> search ID with ID as sql .)


state 120

    (25) sql -> SELECT .

    import          reduce using rule 25 (sql -> SELECT .)
    outcsv          reduce using rule 25 (sql -> SELECT .)
    save            reduce using rule 25 (sql -> SELECT .)
    search          reduce using rule 25 (sql -> SELECT .)
    foreach         reduce using rule 25 (sql -> SELECT .)
    end             reduce using rule 25 (sql -> SELECT .)
    return          reduce using rule 25 (sql -> SELECT .)
    continue        reduce using rule 25 (sql -> SELECT .)
    if              reduce using rule 25 (sql -> SELECT .)
    else            reduce using rule 25 (sql -> SELECT .)
    def             reduce using rule 25 (sql -> SELECT .)
    connect         reduce using rule 25 (sql -> SELECT .)
    let             reduce using rule 25 (sql -> SELECT .)
    list            reduce using rule 25 (sql -> SELECT .)
    ID              reduce using rule 25 (sql -> SELECT .)
    $end            reduce using rule 25 (sql -> SELECT .)


state 121

    (24) command -> list ID EQUALS LPAREN parlist RPAREN .

    import          reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    outcsv          reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    save            reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    search          reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    foreach         reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    end             reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    return          reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    continue        reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    if              reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    else            reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    def             reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    connect         reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    let             reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    list            reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    ID              reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)
    $end            reduce using rule 24 (command -> list ID EQUALS LPAREN parlist RPAREN .)


state 122

    (50) slice -> ID LQPAREN expression COLON expression RQPAREN .

    RPAREN          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    PLUS            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    MINUS           reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    MULTIPLY        reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    DIVIDE          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    POWER           reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    then            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    COMMA           reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    LT              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    LE              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    GT              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    GE              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    EQUALS          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    NE              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    import          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    outcsv          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    save            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    search          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    foreach         reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    end             reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    return          reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    continue        reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    if              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    else            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    def             reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    connect         reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    let             reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    list            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    ID              reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    $end            reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    COLON           reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)
    RQPAREN         reduce using rule 50 (slice -> ID LQPAREN expression COLON expression RQPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 9 resolved as shift
